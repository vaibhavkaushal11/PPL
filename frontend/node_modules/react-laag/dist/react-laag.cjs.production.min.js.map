{"version":3,"file":"react-laag.cjs.production.min.js","sources":["../src/hooks.ts","../src/util.ts","../src/useTrackElements.ts","../src/useGroup.ts","../src/PlacementType.ts","../src/Sides.ts","../src/BoundsOffsets.ts","../src/Bounds.ts","../src/Placement.ts","../src/getArrowStyle.ts","../src/Placements.ts","../src/SubjectsBounds.ts","../src/useLayer.ts","../src/Arrow.ts","../src/useHover.ts","../src/Transition.ts"],"sourcesContent":["import {\n  useRef,\n  useMemo,\n  useLayoutEffect,\n  useEffect,\n  MutableRefObject,\n  useState,\n  MouseEvent\n} from \"react\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility hook to track the reference of a html-element.\n * It notifies the listener when a change occured, so it can act\n * on the change\n */\nexport function useTrackRef(\n  onRefChange: (element: HTMLElement) => void\n): (node: HTMLElement | null) => void {\n  const storedReference = useRef<HTMLElement | null>(null);\n\n  // this is de function that actually gets passed to the `ref` prop\n  // on the html element. I.e.:\n  // <div ref={setter} />\n  function setter(element: HTMLElement | null) {\n    if (!element || element === storedReference.current) {\n      return;\n    }\n\n    storedReference.current = element;\n    onRefChange(element);\n  }\n\n  return setter;\n}\n\n/**\n * Utility hook that stores mutable state.\n * Since a getter function is used, it will always return the most\n * up-to-date state. This is useful when you want to get certain state within\n * an effect, without triggering the same effect when the same state changes.\n * Note: may be seen as an anti-pattern.\n */\nexport function useMutableStore<State>(\n  initialState: State\n): readonly [\n  () => State,\n  {\n    (setter: (state: State) => State): void;\n    (setter: State): void;\n  }\n] {\n  const state = useRef<State>(initialState);\n\n  return useMemo(() => {\n    function set(setter: (state: State) => State): void;\n    function set(setter: State): void;\n    function set(setter: any): void {\n      if (typeof setter === \"function\") {\n        state.current = setter(state.current);\n      } else {\n        state.current = setter;\n      }\n    }\n\n    function get() {\n      return state.current;\n    }\n\n    return [get, set] as const;\n  }, []);\n}\n\n/**\n * Utility hook that keeps track of active event listeners and how\n * to remove these listeners\n */\nexport function useEventSubscriptions() {\n  const subscriptions = useRef<Array<() => void>>([]);\n\n  return useMemo(() => {\n    function hasEventSubscriptions() {\n      return subscriptions.current.length > 0;\n    }\n\n    function removeAllEventSubscriptions() {\n      for (const unsubscribe of subscriptions.current!) {\n        unsubscribe();\n      }\n\n      subscriptions.current = [];\n    }\n\n    function addEventSubscription(unsubscriber: () => void) {\n      subscriptions.current.push(unsubscriber);\n    }\n\n    return {\n      hasEventSubscriptions,\n      removeAllEventSubscriptions,\n      addEventSubscription\n    };\n  }, []);\n}\n\n/**\n * SSR-safe effect hook\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Utility hook that tracks an state object.\n * If `enabled=false` it will discard changes and reset the lastState to `null`\n */\nexport function useLastState<T extends unknown>(\n  currentState: T,\n  enabled: boolean\n): MutableRefObject<T | null> {\n  const lastState = useRef<T | null>(currentState);\n\n  if (!enabled) {\n    lastState.current = null;\n    return lastState;\n  }\n\n  lastState.current = currentState;\n  return lastState;\n}\n\nexport type UseMousePositionAsTriggerOptions = {\n  /**\n   * @description Should the position be actively tracked?\n   * @default true\n   */\n  enabled?: boolean;\n  /**\n   * @description Should `handleMouseEvent` preventDefault()?\n   * @default true\n   */\n  preventDefault?: boolean;\n};\n\nexport type UseMousePositionAsTriggerProps = {\n  hasMousePosition: boolean;\n  resetMousePosition: () => void;\n  handleMouseEvent: (evt: MouseEvent) => void;\n  trigger: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n  parentRef: MutableRefObject<any>;\n};\n\nconst EMPTY_BOUNDS: IBounds = {\n  top: 0,\n  left: 0,\n  right: 1,\n  bottom: 1,\n  width: 1,\n  height: 1\n};\n\n/**\n * @description Utility hook that lets you use the mouse-position as source of the trigger.\n * This is useful in scenario's like context-menu's.\n *\n * @example\n * ```tsx\n * const {\n *  hasMousePosition,\n *  resetMousePosition,\n *  handleMouseEvent,\n *  trigger\n *  } = useMousePositionAsTrigger();\n *\n * const { renderLayer, layerProps } = useLayer({\n *  isOpen: hasMousePosition,\n *  trigger,\n *  onOutsideClick: resetMousePosition\n * });\n *\n * return (\n *  <>\n *   {isOpen && renderLayer(<div {...layerProps} />)}\n *   <div onContextMenu={handleMouseEvent} />\n *  </>\n * );\n * ```\n */\nexport function useMousePositionAsTrigger({\n  enabled = true,\n  preventDefault = true\n}: UseMousePositionAsTriggerOptions = {}): UseMousePositionAsTriggerProps {\n  const parentRef = useRef<any>(null);\n\n  const [mouseBounds, setMouseBounds] = useState<IBounds>(EMPTY_BOUNDS);\n\n  function resetMousePosition() {\n    setMouseBounds(EMPTY_BOUNDS);\n  }\n\n  const hasMousePosition = mouseBounds !== EMPTY_BOUNDS;\n\n  function handleMouseEvent(evt: MouseEvent) {\n    if (!enabled) {\n      return;\n    }\n\n    if (preventDefault) {\n      evt.preventDefault();\n    }\n    const { clientX: left, clientY: top } = evt;\n    setMouseBounds({\n      top,\n      left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      bottom: top + 1\n    });\n  }\n\n  return {\n    hasMousePosition,\n    resetMousePosition,\n    handleMouseEvent,\n    trigger: {\n      getBounds: () => mouseBounds!,\n      getParent: parentRef.current ? () => parentRef.current : undefined\n    },\n    parentRef\n  };\n}\n","/**\n * Convert a pixel value into a numeric value\n * @param value string value (ie. '12px')\n */\nexport function getPixelValue(value: string) {\n  return parseFloat(value.replace(\"px\", \"\"));\n}\n\n/**\n * Returns a numeric value that doesn't exceed min or max\n */\nexport function limit(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Utility function which ensures whether a value is truthy\n */\nexport function isSet<T>(value: T | null | undefined): value is T {\n  return value === null || value === undefined ? false : true;\n}\n\n/**\n * Utility function that let's you assign multiple references to a 'ref' prop\n * @param refs list of MutableRefObject's and / or callbacks\n */\nexport function mergeRefs(...refs: any[]) {\n  return (element: HTMLElement | null) => {\n    for (const ref of refs) {\n      if (!ref) {\n        continue;\n      }\n\n      if (typeof ref === \"function\") {\n        ref(element);\n      } else {\n        ref.current = element!;\n      }\n    }\n  };\n}\n","import { useCallback, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\nimport { ResizeObserverClass, ScrollOffsets, BorderOffsets } from \"./types\";\nimport {\n  useTrackRef,\n  useMutableStore,\n  useEventSubscriptions,\n  useIsomorphicLayoutEffect\n} from \"./hooks\";\nimport { getPixelValue } from \"./util\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility to get the correct ResizeObserver class\n */\nexport function getResizeObserver(\n  environment: Window | undefined,\n  polyfill: ResizeObserverClass | undefined\n): ResizeObserverClass | undefined {\n  if (typeof environment === \"undefined\") {\n    return undefined;\n  }\n\n  return polyfill || (environment as any).ResizeObserver;\n}\n\n/**\n * Utility function that given a element traverses up in the html-hierarchy\n * to find and return all ancestors that have scroll behavior\n */\nexport function findScrollContainers(\n  element: HTMLElement | null,\n  environment?: Window\n): HTMLElement[] {\n  const result: HTMLElement[] = [];\n\n  if (!element || !environment || element === document.body) {\n    return result;\n  }\n\n  const { overflow, overflowX, overflowY } = environment.getComputedStyle(\n    element\n  );\n\n  if (\n    [overflow, overflowX, overflowY].some(prop =>\n      [\"auto\", \"scroll\"].includes(prop)\n    )\n  ) {\n    result.push(element);\n  }\n\n  return [\n    ...result,\n    ...findScrollContainers(element.parentElement, environment)\n  ];\n}\n\nfunction createReferenceError(subject: string) {\n  return `react-laag: Could not find a valid reference for the ${subject} element. There might be 2 causes:\n   - Make sure that the 'ref' is set correctly on the ${subject} element when isOpen: true. Also make sure your component forwards the ref with \"forwardRef()\".\n   - Make sure that you are actually rendering the ${subject} when the isOpen prop is set to true`;\n}\n\nexport type OnChangeElements = {\n  layer: HTMLElement;\n  trigger: HTMLElement;\n  arrow: HTMLElement | null;\n  scrollContainers: HTMLElement[];\n};\n\nexport type UseTrackElementsProps = {\n  enabled: boolean;\n  onChange: (\n    elements: OnChangeElements,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ) => void;\n  environment: Window | undefined;\n  ResizeObserverPolyfill: ResizeObserverClass | undefined;\n  overflowContainer: boolean;\n  triggerOption?: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n};\n\ntype UseTrackElementsReturnValue = {\n  triggerRef: (element: HTMLElement | null) => void;\n  layerRef: (element: HTMLElement | null) => void;\n  arrowRef: React.MutableRefObject<HTMLElement | null>;\n  closestScrollContainer: HTMLElement | null;\n};\n\n/**\n * This hook has the responsibility to track the bounds of:\n * - the trigger element\n * - the layer element\n * - the arrow element\n * - the scroll-containers of which the trigger element is a descendant of\n *\n * It will call the `onChange` callback with a collection of these elements when any\n * of the tracked elements bounds have changed\n *\n * It will detect these changes by listening:\n * - when the reference of the trigger element changes\n * - when the reference of the layer element changes\n * - when the trigger, layer or document body changes in size\n * - when the user scrolls the page, or any of the scroll containers\n */\nexport function useTrackElements({\n  // should we track the bounds?\n  enabled,\n  // call this callback when the bounds have changed\n  onChange,\n  // optional environment (i.e. when using iframes)\n  environment,\n  // optionally inject a polyfill when the browser does not support it\n  // out of the box\n  ResizeObserverPolyfill,\n  // behavior will alter slightly when `overflowContainer` is enabled\n  overflowContainer,\n  // the optional trigger-option provided by the user\n  triggerOption\n}: UseTrackElementsProps): UseTrackElementsReturnValue {\n  // get the correct reference to the ResizeObserver class\n  const ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill);\n\n  // warn the user when no valid ResizeObserver class could be found\n  useEffect(() => {\n    warning(\n      ResizeObserver,\n      `This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://link`\n    );\n  }, [ResizeObserver]);\n\n  // keep reference of the optional arrow-component\n  const arrowRef = useRef<HTMLElement | null>(null);\n\n  // if user has provided the trigger-option we should ingore certain things elsewhere\n  const hasTriggerOption = Boolean(triggerOption);\n\n  // Keep track of mutable element related state\n  // It is generally better to use React.useState, but unfortunately that causes to many re-renders\n  const [get, set] = useMutableStore<{\n    scrollContainers: HTMLElement[];\n    trigger: HTMLElement | null;\n    layer: HTMLElement | null;\n  }>({\n    scrollContainers: [],\n    trigger: null,\n    layer: null\n  });\n\n  // utility to keep track of the scroll and resize listeners and how to unsubscribe them\n  const {\n    hasEventSubscriptions,\n    addEventSubscription,\n    removeAllEventSubscriptions\n  } = useEventSubscriptions();\n\n  // All scroll and resize changes eventually end up here, where the collection of bounds (subjectsBounds) is\n  // constructed in order to notifiy the `onBoundsChange` callback\n  const handleChange = useCallback(\n    function handleChange() {\n      const { layer, trigger, scrollContainers } = get();\n      const closestScrollContainer = scrollContainers[0];\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      // ignore when user has provided the trigger-option\n      if (!trigger && !hasTriggerOption) {\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      let scrollOffsets: ScrollOffsets = { top: 0, left: 0 };\n      if (closestScrollContainer) {\n        const { scrollLeft, scrollTop } = closestScrollContainer;\n        scrollOffsets = {\n          top: scrollTop,\n          left: scrollLeft\n        };\n      } else {\n        const { scrollX, scrollY } = environment!;\n        scrollOffsets = {\n          top: scrollY,\n          left: scrollX\n        };\n      }\n\n      let borderOffsets: BorderOffsets = { left: 0, top: 0 };\n      if (closestScrollContainer) {\n        const {\n          borderLeftWidth,\n          borderTopWidth\n        } = environment!.getComputedStyle(closestScrollContainer);\n\n        borderOffsets = {\n          left: getPixelValue(borderLeftWidth) || 0,\n          top: getPixelValue(borderTopWidth) || 0\n        };\n      }\n\n      onChange(\n        {\n          layer,\n          trigger: trigger!,\n          scrollContainers,\n          arrow: arrowRef.current\n        },\n        scrollOffsets,\n        borderOffsets\n      );\n    },\n    [get, onChange, environment, arrowRef, hasTriggerOption]\n  );\n\n  // responsible for adding the scroll and resize listeners to the correct\n  // html elements\n  const addEventListeners = useCallback(\n    function addEventListeners() {\n      const { trigger, layer, scrollContainers } = get();\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      if (!trigger && !hasTriggerOption) {\n        // ignore when user has provided the trigger-option\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      if (ResizeObserver) {\n        let ignoredInitialCall = false;\n        const observerCallback = () => {\n          if (!ignoredInitialCall) {\n            ignoredInitialCall = true;\n            return;\n          }\n\n          handleChange();\n        };\n\n        const observer = new ResizeObserver(observerCallback);\n        for (const element of [trigger, layer, document.body]) {\n          if (element) observer.observe(element);\n        }\n\n        addEventSubscription(() => {\n          for (const element of [trigger, layer, document.body]) {\n            if (element) observer.unobserve(element);\n          }\n          observer.disconnect();\n        });\n      }\n\n      const listenForScrollElements = [environment!, ...scrollContainers];\n      for (const element of listenForScrollElements) {\n        element.addEventListener(\"scroll\", handleChange);\n\n        addEventSubscription(() =>\n          element.removeEventListener(\"scroll\", handleChange)\n        );\n      }\n    },\n    [\n      get,\n      addEventSubscription,\n      handleChange,\n      environment,\n      ResizeObserver,\n      hasTriggerOption\n    ]\n  );\n\n  // when either the reference to the trigger or layer element changes\n  // we should reset the event listeners and trigger a `onChange`\n  const resetWhenReferenceChangedWhileTracking = useCallback(\n    (previous: HTMLElement | null, next: HTMLElement) => {\n      if (enabled && previous && previous !== next) {\n        removeAllEventSubscriptions();\n        addEventListeners();\n        handleChange();\n      }\n    },\n    [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]\n  );\n\n  // Logic when reference to layer changes\n  const layerRef = useTrackRef(\n    useCallback(\n      layer => {\n        const { layer: previousLayer } = get();\n\n        // store new reference\n        set(state => ({\n          ...state,\n          layer\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousLayer, layer);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking]\n    )\n  );\n\n  const getScrollContainers = useCallback(\n    function handleScrollContainers(element: HTMLElement) {\n      const scrollContainers = findScrollContainers(element, environment);\n\n      const closestScrollContainer = scrollContainers[0];\n\n      if (closestScrollContainer) {\n        // Check if we should warn the user about 'position: relative; stuff...'\n        const position = environment!.getComputedStyle(closestScrollContainer)\n          .position;\n\n        const closestScrollContainerHasCorrectStyling =\n          [\"relative\", \"absolute\", \"fixed\"].includes(position) ||\n          overflowContainer;\n\n        if (!closestScrollContainerHasCorrectStyling) {\n          closestScrollContainer.style.position = \"relative\";\n        }\n\n        warning(\n          closestScrollContainerHasCorrectStyling,\n          `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: \"${position}\". For now, \"position: relative;\" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.`\n        );\n      }\n      return scrollContainers;\n    },\n    [environment, overflowContainer]\n  );\n\n  // Logic when reference to trigger changes\n  // Note: this will have no effect when user provided the trigger-option\n  const triggerRef = useTrackRef(\n    useCallback(\n      trigger => {\n        // collect list of scroll containers\n        const scrollContainers = getScrollContainers(trigger);\n\n        const { trigger: previousTrigger } = get();\n\n        // store new references\n        set(state => ({\n          ...state,\n          trigger,\n          scrollContainers\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers]\n    )\n  );\n\n  // when user has provided the trigger-option, it monitors the optional parent-element\n  // in order to determine the scroll-containers\n  const triggerOptionParent = triggerOption?.getParent?.();\n  useIsomorphicLayoutEffect(() => {\n    if (!triggerOptionParent) {\n      return;\n    }\n    set(state => ({\n      ...state,\n      scrollContainers: getScrollContainers(triggerOptionParent)\n    }));\n  }, [triggerOptionParent, set, getScrollContainers]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // add event listeners if necessary\n      if (!hasEventSubscriptions()) {\n        addEventListeners();\n      }\n    }\n\n    return () => {\n      if (hasEventSubscriptions()) {\n        removeAllEventSubscriptions();\n      }\n    };\n  }, [\n    enabled,\n    hasEventSubscriptions,\n    addEventListeners,\n    removeAllEventSubscriptions\n  ]);\n\n  // run this effect after every render\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // eventually call `handleChange` with latest elements-refs\n      handleChange();\n    }\n  });\n\n  return {\n    triggerRef,\n    layerRef,\n    arrowRef,\n    closestScrollContainer: get().scrollContainers[0] || null\n  };\n}\n","import {\n  ReactNode,\n  createContext,\n  MutableRefObject,\n  useCallback,\n  useRef,\n  useContext,\n  useEffect,\n  createElement\n} from \"react\";\nimport warning from \"tiny-warning\";\n\ntype Registration = {\n  shouldCloseWhenClickedOutside: (event: MouseEvent) => boolean;\n  closeChild: () => void;\n};\n\ntype Registrations = Set<Registration>;\n\ntype RegisterFn = (registration: Registration) => () => void;\n\ntype GroupContextType = {} | RegisterFn;\n\nconst GroupContext = createContext({} as GroupContextType);\n\ntype GroupProviderProps = {\n  children: ReactNode;\n  registrations: MutableRefObject<Registrations>;\n};\n\n// Provider that wraps arround the layer in order to provide other useLayers\n// down in the hiearchy (child layers) with means to communicate with the parent.\n// This provider receives a `registrations` Set which can be used to add and\n// delete registrations.\nexport function GroupProvider({ children, registrations }: GroupProviderProps) {\n  // registration function that is used as 'context payload' for child layers\n  // to call. It returns a function to unregister.\n  const handleRegister = useCallback(\n    function register(registration: Registration) {\n      registrations.current.add(registration);\n\n      return () => registrations.current.delete(registration);\n    },\n    [registrations]\n  );\n\n  return createElement(\n    GroupContext.Provider,\n    { value: handleRegister },\n    children\n  );\n}\n\n// asks child layers if they would close given the documents click event\n// if there's one that signals not to close, return early (false)\nfunction getShouldCloseAccordingToChildren(\n  registrations: Registrations,\n  event: MouseEvent\n) {\n  for (const { shouldCloseWhenClickedOutside } of registrations) {\n    if (!shouldCloseWhenClickedOutside(event)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype UseGroup = {\n  isOpen: boolean;\n  onOutsideClick?: () => void;\n  onParentClose?: () => void;\n};\n\n/**\n * Responsible for close behavior\n * When the `onOutsideClick` callback is provided by the user, it will listen for clicks\n * in the document, and tell whether the user clicked outside -> not on layer / trigger.\n * It keeps track of nested useLayers a.k.a child layers (`registrations` Set), through which\n * we can ask whether they `shouldCloseWhenClickedOutside`, or tell them to close.\n *\n * Behavior:\n * - `onOutsideClick` only works on the most outer parent, and not on children. The parent will ask\n *   the child layers whether they would close, and will handle accordingly. The parent may\n *   command the children to close indirectly with the help of `onParentClose`\n * - When the parent just was closed, it will make sure that any children will also close\n *   with the help of `onParentClose`\n */\nexport function useGroup({ isOpen, onOutsideClick, onParentClose }: UseGroup) {\n  // store references to the dom-elements\n  // we need these to later determine wether the clicked outside or not\n  const trigger = useRef<HTMLElement>(null!);\n  const layer = useRef<HTMLElement>(null!);\n\n  // a Set which keeps track of callbacks given by the child layers through context\n  const registrations = useRef<Registrations>(new Set());\n\n  // if this instance is a child itself, we should use this function to register\n  // some callbacks to the parent\n  const possibleRegisterFn = useContext(GroupContext);\n\n  // recursively checks whether to close or not. This mechanism has some similarities\n  // with event bubbling.\n  const shouldCloseWhenClickedOutside = useCallback(\n    function shouldCloseWhenClickedOutside(event: MouseEvent) {\n      const target = event.target as HTMLElement;\n\n      const clickedOnTrigger =\n        trigger.current && trigger.current.contains(target);\n      const clickedOnLayer = layer.current && layer.current.contains(target);\n\n      const shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(\n        registrations.current,\n        event\n      );\n\n      // when clicked on own layer, but the child would have closed ->\n      // let child close\n      if (clickedOnLayer && shouldCloseAccordingToChildren) {\n        registrations.current.forEach(({ closeChild }) => closeChild());\n      }\n\n      return (\n        !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren\n      );\n    },\n    [trigger, layer, registrations]\n  );\n\n  // registration stuff\n  useEffect(() => {\n    if (typeof possibleRegisterFn !== \"function\") {\n      return;\n    }\n\n    // 'possibleRegisterFn' will return a function that will unregister\n    // on cleanup\n    return possibleRegisterFn({\n      shouldCloseWhenClickedOutside,\n      closeChild: () => {\n        warning(\n          onParentClose,\n          `react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.`\n        );\n\n        if (onParentClose) {\n          onParentClose();\n        }\n      }\n    });\n  }, [\n    possibleRegisterFn,\n    shouldCloseWhenClickedOutside,\n    onParentClose,\n    registrations\n  ]);\n\n  // document click handling\n  useEffect(() => {\n    const isChild = typeof possibleRegisterFn === \"function\";\n    const shouldNotListen = !isOpen || !onOutsideClick || isChild;\n    if (shouldNotListen) {\n      return;\n    }\n\n    function handleClick(event: MouseEvent) {\n      if (shouldCloseWhenClickedOutside(event)) {\n        onOutsideClick!();\n      }\n    }\n\n    document.addEventListener(\"click\", handleClick, true);\n    return () => document.removeEventListener(\"click\", handleClick, true);\n  }, [\n    isOpen,\n    onOutsideClick,\n    shouldCloseWhenClickedOutside,\n    possibleRegisterFn\n  ]);\n\n  // When this 'useLayer' gets closed -> tell child layers to close as well\n  useEffect(() => {\n    if (!isOpen) {\n      registrations.current.forEach(({ closeChild }) => closeChild());\n    }\n  }, [isOpen]);\n\n  return {\n    closeOnOutsideClickRefs: {\n      trigger,\n      layer\n    },\n    registrations\n  };\n}\n","export const PLACEMENT_TYPES: PlacementType[] = [\n  \"bottom-start\",\n  \"bottom-end\",\n  \"bottom-center\",\n  \"top-start\",\n  \"top-center\",\n  \"top-end\",\n  \"left-end\",\n  \"left-center\",\n  \"left-start\",\n  \"right-end\",\n  \"right-center\",\n  \"right-start\",\n  \"center\"\n];\n\nexport type PlacementType =\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"bottom-center\"\n  | \"top-start\"\n  | \"top-center\"\n  | \"top-end\"\n  | \"left-end\"\n  | \"left-center\"\n  | \"left-start\"\n  | \"right-end\"\n  | \"right-center\"\n  | \"right-start\"\n  | \"center\";\n","export type BoundSideProp = \"top\" | \"left\" | \"bottom\" | \"right\";\nexport type SideProp = BoundSideProp | \"center\";\ntype SizeProp = \"width\" | \"height\";\ntype CssProp = \"top\" | \"left\";\n\nconst OPPOSITES: Record<SideProp, SideProp> = {\n  top: \"bottom\",\n  left: \"right\",\n  bottom: \"top\",\n  right: \"left\",\n  center: \"center\"\n};\n\nclass SideBase<T extends SideProp> {\n  constructor(\n    readonly prop: T,\n    readonly opposite: SideBase<T>,\n    readonly isHorizontal: boolean,\n    readonly sizeProp: SizeProp,\n    readonly oppositeSizeProp: SizeProp,\n    readonly cssProp: CssProp,\n    readonly oppositeCssProp: CssProp,\n    readonly isCenter: boolean,\n    readonly isPush: boolean // left | top\n  ) {}\n\n  factor(value: number) {\n    return value * (this.isPush ? 1 : -1);\n  }\n\n  isOppositeDirection(side: SideBase<any>) {\n    return this.isHorizontal !== side.isHorizontal;\n  }\n}\n\nfunction createSide<T extends SideProp>(\n  prop: T,\n  recursive = true\n): SideBase<T> {\n  const isHorizontal = [\"left\", \"right\"].includes(prop);\n\n  return new SideBase<T>(\n    prop,\n    recursive ? createSide<T>((OPPOSITES as any)[prop], false) : null!,\n    isHorizontal,\n    isHorizontal ? \"width\" : \"height\",\n    isHorizontal ? \"height\" : \"width\",\n    isHorizontal ? \"left\" : \"top\",\n    isHorizontal ? \"top\" : \"left\",\n    prop === \"center\",\n    ![\"right\", \"bottom\"].includes(prop)\n  );\n}\n\nexport type BoundSideType = SideBase<BoundSideProp>;\nexport type SideType = SideBase<SideProp>;\n\nexport const BoundSide = {\n  top: createSide(\"top\") as BoundSideType,\n  bottom: createSide(\"bottom\") as BoundSideType,\n  left: createSide(\"left\") as BoundSideType,\n  right: createSide(\"right\") as BoundSideType\n};\n\nexport const Side = {\n  ...(BoundSide as {\n    top: SideType;\n    left: SideType;\n    bottom: SideType;\n    right: SideType;\n  }),\n  center: createSide(\"center\")\n};\n","export interface IBoundsOffsets {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n}\n\nconst SIDES = [\"top\", \"left\", \"bottom\", \"right\"] as (keyof IBoundsOffsets)[];\n\n/**\n * A class containing the positional properties which represent the distance\n * between two Bounds instances for each side\n */\nexport class BoundsOffsets implements IBoundsOffsets {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n\n  constructor(offsets: IBoundsOffsets) {\n    return Object.assign(this, offsets);\n  }\n\n  /**\n   * Takes multiple BoundsOffets instances and creates a new BoundsOffsets instance\n   * by taking the smallest value for each side\n   * @param boundsOffsets list of BoundsOffsets instances\n   */\n  static mergeSmallestSides(boundsOffsets: BoundsOffsets[]): BoundsOffsets {\n    const [first, ...rest] = boundsOffsets;\n\n    if (!first) {\n      throw new Error(\n        \"Please provide at least 1 bounds objects in order to merge\"\n      );\n    }\n\n    const result: IBoundsOffsets = Object.fromEntries(\n      SIDES.map(side => [side, first[side]])\n    ) as any;\n\n    for (const boundsOffset of rest) {\n      for (const side of SIDES) {\n        result[side] = Math.min(result[side], boundsOffset[side]);\n      }\n    }\n\n    return new BoundsOffsets(result);\n  }\n\n  /**\n   * Checks whether all sides sides are positive, meaning the corresponding Bounds instance\n   * fits perfectly within a parent Bounds instance\n   */\n  get allSidesArePositive(): boolean {\n    return SIDES.every(side => this[side] >= 0);\n  }\n\n  /**\n   * Returns a partial IBoundsOffsets with sides that are negative, meaning sides aren't entirely\n   * visible in respect to a parent Bounds instance\n   */\n  get negativeSides(): Partial<IBoundsOffsets> {\n    return Object.fromEntries(\n      SIDES.filter(side => this[side] < 0).map(side => [side, this[side]])\n    ) as Partial<IBoundsOffsets>;\n  }\n}\n","import { BoundSide, BoundSideProp, BoundSideType } from \"./Sides\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { getPixelValue } from \"./util\";\n\n/**\n * Utility function that returns sum of various computed styles\n * @param propertyValues list of computed styles (ie. '12px')\n */\nfunction sumOfPropertyValues(...propertyValues: string[]) {\n  return propertyValues.reduce(\n    (sum, propertyValue) =>\n      sum + (propertyValue ? getPixelValue(propertyValue!) : 0),\n    0\n  );\n}\n\nexport interface IBounds {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}\n\nexport function boundsToObject({\n  top,\n  left,\n  right,\n  bottom,\n  width,\n  height\n}: IBounds): IBounds {\n  return { top, left, right, bottom, width, height };\n}\n\nconst EMPTY: IBounds = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: 0,\n  height: 0\n};\n\n/**\n * A class containing the positional properties of the native DOM's ClientRect\n * (`element.getBoundingClientRect()`), together with some utility methods\n */\nexport class Bounds implements IBounds {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n  width!: number;\n  height!: number;\n\n  /**\n   * Creates a new Bounds class\n   * @param bounds An object that adheres to the `IBounds` interface\n   */\n  static create(bounds: IBounds): Bounds {\n    return new Bounds(bounds);\n  }\n\n  /**\n   * Creates a new Bounds class from a DOM-element\n   * @param element reference to the DOM-element\n   * @param options optional options object\n   */\n  static fromElement(\n    element: HTMLElement,\n    options: {\n      /** should transforms like 'scale' taken into account? Defaults to `true` */\n      withTransform?: boolean;\n      /** reference to the window-object (needed when working with iframes for instance). Defaults to `window` */\n      environment?: Window;\n      /** should the elements scrollbars be included? Defaults to `true` */\n      withScrollbars?: boolean;\n    } = {}\n  ): Bounds {\n    const {\n      withTransform = true,\n      environment = window,\n      withScrollbars = true\n    } = options;\n\n    const plain: IBounds = boundsToObject(element.getBoundingClientRect());\n\n    let bounds: Bounds = new Bounds(plain);\n\n    if (!withTransform) {\n      const {\n        width,\n        height,\n        boxSizing,\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        paddingLeft,\n        paddingRight,\n        paddingTop,\n        paddingBottom\n      } = environment.getComputedStyle(element);\n\n      const boxWidth =\n        boxSizing === \"border-box\"\n          ? getPixelValue(width!)\n          : sumOfPropertyValues(\n              width,\n              borderLeft,\n              borderRight,\n              paddingLeft,\n              paddingRight\n            );\n\n      const boxHeight =\n        boxSizing === \"border-box\"\n          ? getPixelValue(height!)\n          : sumOfPropertyValues(\n              height,\n              borderTop,\n              borderBottom,\n              paddingTop,\n              paddingBottom\n            );\n\n      bounds = new Bounds({\n        ...bounds,\n        width: boxWidth,\n        height: boxHeight\n      });\n    }\n\n    if (!withScrollbars) {\n      const scrollbarWidth = bounds.width - element.clientWidth;\n      const scrollbarHeight = bounds.height - element.clientHeight;\n      return bounds.substract({\n        right: scrollbarWidth,\n        bottom: scrollbarHeight\n      });\n    }\n\n    return bounds;\n  }\n\n  /**\n   * Creates an empty Bounds class\n   */\n  static empty(): Bounds {\n    return new Bounds();\n  }\n\n  /**\n   * Creates a Bounds class from the window's dimensions\n   * @param environment reference to the window-object (needed when working with iframes for instance). Defaults to `window`\n   */\n  static fromWindow(environment?: Window): Bounds {\n    const { innerWidth: width = 0, innerHeight: height = 0 } =\n      environment || {};\n    return new Bounds({ width, height, right: width, bottom: height });\n  }\n\n  protected constructor(bounds: Partial<IBounds> = {}) {\n    return Object.assign(this, EMPTY, bounds);\n  }\n\n  /**\n   * Returns the square surface of the bounds in pixels\n   */\n  get surface(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * Returns a plain object containing only positional properties\n   */\n  toObject(): IBounds {\n    return boundsToObject(this);\n  }\n\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param bounds partial bounds which should be merged\n   */\n  merge(bounds: Partial<IBounds>): Bounds;\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param mergeFn callback which takes the current bounds and returns new merged bounds\n   */\n  merge(mergeFn: (current: IBounds) => Partial<IBounds>): Bounds;\n  merge(partialBoundsOrMergeFn: unknown): Bounds {\n    const current = this.toObject();\n    return new Bounds({\n      ...current,\n      ...(typeof partialBoundsOrMergeFn === \"function\"\n        ? partialBoundsOrMergeFn(current)\n        : partialBoundsOrMergeFn)\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by subtracting each property of the provided IBounds object\n   * @param bounds partial IBounds object to substract with\n   */\n  substract(bounds: Partial<IBounds>): Bounds {\n    const result = this.toObject();\n\n    const entries = Object.entries(bounds) as [keyof IBounds, number][];\n\n    for (const [prop, value] of entries) {\n      if (prop in BoundSide) {\n        // if `prop` is one of 'top', 'left', 'bottom' or 'right'...\n        const boundSide = BoundSide[prop as BoundSideProp];\n        // decide if we should add or substract\n        result[prop] += boundSide.factor(value);\n        // make sure that the size-properties are also updated\n        result[boundSide.isHorizontal ? \"width\" : \"height\"] -= value;\n      } else {\n        // prop is 'width' or 'height'\n        result[prop] -= value || 0;\n      }\n    }\n\n    return new Bounds(result);\n  }\n\n  /**\n   * Returns a new BoundsOffsets instance by determining the distance for each bound-side:\n   * (child -> parent)\n   * @param child child bounds instance\n   */\n  offsetsTo(child: Bounds): BoundsOffsets {\n    return new BoundsOffsets({\n      top: child.top - this.top,\n      bottom: this.bottom - child.bottom,\n      left: child.left - this.left,\n      right: this.right - child.right\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by mapping over each bound-side\n   * @param mapper callback that takes a boundSide + value in pixels, returning a new value for that side\n   */\n  mapSides(\n    mapper: (boundSide: BoundSideType, value: number) => number\n  ): Bounds {\n    const result = this.toObject();\n    const boundSides = Object.values(BoundSide) as BoundSideType[];\n    for (const boundSide of boundSides) {\n      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);\n    }\n    return new Bounds(result);\n  }\n}\n","import { BoundSideType, SideType, BoundSide, BoundSideProp } from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { PositionConfig, Offsets } from \"./types\";\nimport { Bounds, IBounds } from \"./Bounds\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { limit } from \"./util\";\n\n/**\n * Class for various calculations based on a placement-type. I.e 'top-left';\n */\nexport class Placement {\n  protected subjectsBounds!: SubjectsBounds;\n  private _cachedLayerBounds: Bounds | null = null;\n  private _cachedContainerOffsets: BoundsOffsets | null = null;\n\n  constructor(\n    public readonly primary: SideType,\n    public readonly secondary: SideType,\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"],\n    private readonly offsets: Offsets\n  ) {\n    this.setSubjectsBounds(subjectBounds, layerDimensions);\n  }\n\n  /**\n   * Set subjectsBounds that are specific for this placement\n   * @param subjectBounds original SubjectBounds instance\n   * @param layerDimensions possible config prodvided by the user\n   */\n  private setSubjectsBounds(\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"]\n  ): void {\n    // if user did not provide any layerDimensions config...\n    if (!layerDimensions) {\n      this.subjectsBounds = subjectBounds;\n      return;\n    }\n\n    // get anticipated layer-dimensions provided by the user\n    const dimensions =\n      // if the user passed a callback, call it with the layerSide corresponding to\n      // the placement\n      typeof layerDimensions === \"function\"\n        ? layerDimensions(this.primary.prop)\n        : layerDimensions;\n\n    // create new SubjectsBounds instance by merging our newly create layer-bounds\n    this.subjectsBounds = subjectBounds.merge({\n      layer: {\n        ...subjectBounds.layer,\n        ...dimensions\n      }\n    });\n  }\n\n  /**\n   * Returns the string respresentation of this placement (ie. 'top-start')\n   */\n  public get type(): PlacementType {\n    return `${this.primary.prop}-${\n      this.secondary.prop === \"center\"\n        ? \"center\"\n        : [\"bottom\", \"right\"].includes(this.secondary.prop)\n        ? \"end\"\n        : \"start\"\n    }` as PlacementType;\n  }\n\n  /**\n   * Calculates the actual boundaries based on the placement\n   * @param secondaryOffset optional offset on the secondary-side\n   */\n  public getLayerBounds(secondaryOffset = 0): Bounds {\n    // return cached version if possible\n    if (this._cachedLayerBounds && secondaryOffset === 0) {\n      return this._cachedLayerBounds;\n    }\n\n    const { primary, secondary, subjectsBounds } = this;\n    const { trigger, layer, arrow } = subjectsBounds;\n    const {\n      isHorizontal,\n      oppositeCssProp,\n      oppositeSizeProp,\n      prop,\n      opposite\n    } = primary as BoundSideType;\n\n    const result = Bounds.empty() as IBounds;\n\n    // let's take the placement 'top-start' as an example...\n    // the offsets are the following:\n    // trigger -> 8px\n    // container -> 10px;\n    // arrow -> 2px;\n\n    // PRIMARY STUFF\n\n    // bottom = trigger.top + 8;\n    result[opposite.prop] =\n      trigger[prop] - primary.factor(this.offsets.trigger);\n\n    // top = bottom - layer.height\n    result[prop] =\n      result[opposite.prop] - primary.factor(layer[primary.sizeProp]);\n\n    // SECONDARY STUFF\n\n    // arrowOffsetBase = 4\n    const arrowOffsetBase = this.offsets.arrow * 2;\n\n    // limitMin = trigger.left - (layer.width - arrow.width) + 4\n    let limitMin =\n      trigger[oppositeCssProp] -\n      (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) +\n      arrowOffsetBase;\n    // limitMax = trigger.left + (trigger.width - arrow.width) - 4\n    let limitMax =\n      trigger[oppositeCssProp] +\n      (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) -\n      arrowOffsetBase;\n\n    if (!secondary.isPush) {\n      // if secondary is bottom or right -> add the width or height of the layer\n      limitMin += layer[oppositeSizeProp];\n      limitMax += layer[oppositeSizeProp];\n    }\n\n    if (secondary.isCenter) {\n      const propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;\n      const propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right)\n        .prop;\n\n      // left = limit(\n      //   trigger.left + trigger.width / 2 - layer.width / 2 + secondaryOffset,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[propertyA] = limit(\n        trigger[propertyA] +\n          trigger[oppositeSizeProp] / 2 -\n          layer[oppositeSizeProp] / 2 +\n          secondaryOffset,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];\n    } else {\n      const sec = secondary as BoundSideType;\n\n      const triggerValue = trigger[sec.prop];\n\n      // Under some conditions, when the layer is not able to align with the trigger\n      // due to arrow-size and arrow-offsets, we need to compensate.\n      // Otherwise, the secondary-offset will have no impact\n      const arrowCompensation =\n        triggerValue < limitMin\n          ? limitMin - triggerValue\n          : triggerValue > limitMax\n          ? limitMax - triggerValue\n          : 0;\n\n      // left = limit(\n      //   trigger.left + secondaryOffset + arrowCompensation,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[sec.prop] = limit(\n        triggerValue + secondaryOffset + arrowCompensation,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[sec.opposite.prop] =\n        result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);\n    }\n\n    // set the correct dimensions\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    // create new bounds object\n    const layerBounds = Bounds.create(result);\n\n    if (secondaryOffset === 0) {\n      this._cachedLayerBounds = layerBounds;\n    }\n\n    return layerBounds;\n  }\n\n  /**\n   * Checks whether the trigger is bigger on the opposite side\n   * ie. placement \"top-start\" -> has trigger a bigger width?\n   */\n  public get triggerIsBigger() {\n    const { isHorizontal } = this.secondary;\n    const {\n      triggerHasBiggerWidth,\n      triggerHasBiggerHeight\n    } = this.subjectsBounds;\n\n    return (\n      (isHorizontal && triggerHasBiggerWidth) ||\n      (!isHorizontal && triggerHasBiggerHeight)\n    );\n  }\n\n  /**\n   * Checks whether the placement fits within all it's container (including container-offset)\n   */\n  public get fitsContainer(): boolean {\n    return this.getContainerOffsets().allSidesArePositive;\n  }\n\n  /**\n   * Returns the surface in square pixels of the visible part of the layer\n   */\n  public get visibleSurface(): number {\n    const layerBounds = this.getLayerBounds();\n    const containerOffsets = this.getContainerOffsets(layerBounds);\n\n    const substract = containerOffsets.negativeSides;\n    for (const side in substract) {\n      // @ts-ignore\n      substract[side] = -substract[side]; // make positive for substraction;\n    }\n\n    return layerBounds.substract(substract).surface;\n  }\n\n  /**\n   * Returns a BoundSide by looking at the most negative offset that is the opposite direction\n   */\n  public get secondaryOffsetSide(): BoundSideType | null {\n    // Given placement 'top-start' and containerOffsets { left: -20, top: -10, right: -10, bottom: 200 }...\n    // the only negative offsets on the opposite side are { left: -20, right: -10 }\n    // since we have to return only 1 side, we pick the most negative, which is 'left'\n\n    const containerOffsets = this.getContainerOffsets();\n\n    const [mostNegativeSide] =\n      Object.entries(containerOffsets.negativeSides)\n        .map(\n          ([side, value]) => [BoundSide[side as BoundSideProp], value] as const\n        )\n        .filter(([side]) => this.primary.isOppositeDirection(side))\n        .sort(([, a], [, b]) => b! - a!)?.[0] ?? [];\n\n    return mostNegativeSide || null;\n  }\n\n  /**\n   * returns getLayerBounds(), including container-offsets\n   */\n  private getLayerCollisionBounds(): Bounds {\n    const { container } = this.offsets;\n\n    return this.getLayerBounds()\n      .mapSides((side, value) => (value -= side.factor(container)))\n      .merge(({ width, height }) => ({\n        width: width + container * 2,\n        height: height + container * 2\n      }));\n  }\n\n  /**\n   * Returns a BoundsOffsets instance containing merged offsets to containers with the most\n   * negative scenario\n   */\n  public getContainerOffsets(layerBounds?: Bounds): BoundsOffsets {\n    if (this._cachedContainerOffsets && !layerBounds) {\n      return this._cachedContainerOffsets;\n    }\n\n    const subjectBounds = this.subjectsBounds.merge({\n      layer: layerBounds || this.getLayerCollisionBounds()\n    });\n\n    const offsets = BoundsOffsets.mergeSmallestSides(\n      subjectBounds.layerOffsetsToScrollContainers\n    );\n\n    if (!layerBounds) {\n      this._cachedContainerOffsets = offsets;\n    }\n\n    return offsets;\n  }\n}\n\nexport class PlacementCenter extends Placement {\n  getLayerBounds(): Bounds {\n    const { trigger, layer } = this.subjectsBounds;\n\n    const result = Bounds.empty() as IBounds;\n\n    result.top = trigger.top + trigger.height / 2 - layer.height / 2;\n    result.bottom = result.top + layer.height;\n    result.left = trigger.left + trigger.width / 2 - layer.width / 2;\n    result.right = result.left + layer.width;\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    return result as Bounds;\n  }\n}\n","import { limit } from \"./util\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { Placement } from \"./Placement\";\n\n// how much pixels is the center of layer removed from edge of trigger?\nfunction getNegativeOffsetBetweenLayerCenterAndTrigger(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n) {\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n\n  const [sideA, sideB] = !placement.primary.isHorizontal\n    ? ([\"left\", \"right\"] as const)\n    : ([\"top\", \"bottom\"] as const);\n\n  const offsetA =\n    layer[sideA] +\n    layer[sizeProperty] / 2 -\n    trigger[sideA] -\n    arrow[sizeProperty] / 2 -\n    arrowOffset;\n  const offsetB =\n    layer[sideB] -\n    layer[sizeProperty] / 2 -\n    trigger[sideB] +\n    arrow[sizeProperty] / 2 +\n    arrowOffset;\n\n  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);\n}\n\nconst STYLE_BASE: React.CSSProperties = {\n  position: \"absolute\",\n  willChange: \"top, left\",\n  left: null!,\n  right: null!,\n  top: null!,\n  bottom: null!\n};\n\nexport function getArrowStyle(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n): React.CSSProperties {\n  if (placement.primary.isCenter) {\n    return STYLE_BASE;\n  }\n\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n  const triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];\n\n  const min = arrowOffset + arrow[sizeProperty] / 2;\n  const max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;\n\n  const negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(\n    subjectsBounds,\n    placement,\n    arrowOffset\n  );\n\n  const primarySide = placement.primary.prop;\n  const secondarySide = placement.primary.oppositeCssProp;\n\n  const secondaryValue = triggerIsBigger\n    ? layer[sizeProperty] / 2 + negativeOffset\n    : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];\n\n  return {\n    ...STYLE_BASE,\n    [primarySide]: \"100%\",\n    [secondarySide]: limit(secondaryValue, min, max)\n  };\n}\n","import { CSSProperties } from \"react\";\nimport {\n  BoundSide,\n  Side,\n  BoundSideType,\n  SideType,\n  BoundSideProp,\n  SideProp\n} from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { Placement, PlacementCenter } from \"./Placement\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport {\n  PositionConfig,\n  Offsets,\n  ScrollOffsets,\n  BorderOffsets,\n  DisappearType,\n  Styles\n} from \"./types\";\nimport { Bounds } from \"./Bounds\";\nimport { getArrowStyle } from \"./getArrowStyle\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\n\n/**\n * Class mostly concerned about calculating and finding the right placement\n */\nexport class Placements {\n  protected constructor(\n    public readonly placements: Placement[],\n    private config: PositionConfig,\n    private subjectsBounds: SubjectsBounds\n  ) {}\n\n  /**\n   * Converts a placement-type into a primary-side and a secondary-side\n   */\n  static getSidesFromPlacementType(\n    type: PlacementType\n  ): [BoundSideType, SideType] {\n    let [a, b] = (type.split(\"-\") as unknown) as [\n      keyof typeof BoundSide,\n      \"start\" | \"center\" | \"end\"\n    ];\n\n    const primary = BoundSide[a];\n    let secondary: SideType;\n    if (b === \"center\") {\n      secondary = Side.center;\n    } else if (primary.isHorizontal) {\n      secondary = b === \"start\" ? Side.top : Side.bottom;\n    } else {\n      secondary = b === \"start\" ? Side.left : Side.right;\n    }\n\n    return [primary, secondary];\n  }\n\n  /**\n   * Main static method to create a Placements instance\n   * @param subjectsBounds instance of the SubjectsBounds class\n   * @param config config provided by the user\n   */\n  static create(\n    subjectsBounds: SubjectsBounds,\n    config: PositionConfig\n  ): Placements {\n    // create offsets-object from user config\n    const offsets: Offsets = {\n      arrow: config.arrowOffset,\n      container: config.containerOffset,\n      trigger: config.triggerOffset\n    };\n\n    // function which creates a prioritized list of possible placments\n    // by looking at user-config\n    function getListOfPlacements(preferedPlacement = config.placement) {\n      const [primary, secondary] = Placements.getSidesFromPlacementType(\n        preferedPlacement\n      );\n\n      const preferredSide =\n        BoundSide[primary.isHorizontal ? config.preferY : config.preferX];\n\n      // some priorities may alter when the trigger is bigger\n      const triggerIsBigger =\n        (!primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth) ||\n        (primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight);\n\n      // utility function which constructs a placement by primary and secondary sides\n      function placementFrom(\n        primary: BoundSideType,\n        secondary: SideType\n      ): Placement {\n        return new Placement(\n          primary,\n          secondary,\n          subjectsBounds,\n          config.layerDimensions,\n          offsets\n        );\n      }\n\n      // creating the list\n      let list: Placement[] = [];\n      list[0] = placementFrom(primary, secondary);\n      list[1] = placementFrom(\n        primary,\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[2] = placementFrom(\n        primary,\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n      list[3] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[4] = placementFrom(preferredSide, Side.center);\n      list[5] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[6] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[7] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        Side.center\n      );\n      list[8] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);\n      list[10] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[11] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n\n      // only include placements that are part of 'possible-placements'\n      list = list.filter(\n        placement =>\n          placement.type === config.placement ||\n          config.possiblePlacements.includes(placement.type)\n      );\n\n      return list;\n    }\n\n    // treat placement 'center' a little bit different\n    if (config.placement === \"center\") {\n      return new Placements(\n        [\n          new PlacementCenter(\n            Side.center,\n            Side.center,\n            subjectsBounds,\n            config.layerDimensions,\n            offsets\n          ),\n          ...getListOfPlacements(\n            `${config.preferY}-${config.preferX}` as PlacementType\n          )\n        ],\n        config,\n        subjectsBounds\n      );\n    }\n\n    return new Placements(getListOfPlacements(), config, subjectsBounds);\n  }\n\n  private filterPlacementsBySide(side: SideType): Placement[] {\n    return this.placements.filter(placement => placement.primary === side);\n  }\n\n  private findFirstPlacementThatFits(): Placement | undefined {\n    return this.placements.find(placement => placement.fitsContainer);\n  }\n\n  private placementWithBiggestVisibleSurface(): Placement {\n    const [{ placement: placementWithBiggestSurface }] = this.placements\n      .map(placement => ({\n        placement,\n        surface: placement.visibleSurface\n      }))\n      // sort -> biggest surface first\n      .sort((a, b) => b.surface - a.surface);\n\n    return placementWithBiggestSurface;\n  }\n\n  private findSuitablePlacement(): Placement {\n    if (!this.config.auto) {\n      return this.placements[0];\n    }\n\n    return (\n      this.findFirstPlacementThatFits() ||\n      this.placementWithBiggestVisibleSurface()\n    );\n  }\n\n  /**\n   * secondary offset: the number of pixels between the edge of the\n   * scroll-container and the current placement, on the side of the layer\n   * that didn't fit.\n   * Eventually this secondary offset gets added / subtracted from the\n   * placement that does fit in order to move the layer closer to the\n   * position of the placement that just would not fit.\n   * This creates the effect that the layer is moving gradually from one\n   * placement to the next as the users scrolls the page or scroll-container\n   */\n  private getSecondaryOffset(placement: Placement): number {\n    const { auto, snap } = this.config;\n\n    // return early when we're not interested...\n    if (!auto || snap || placement instanceof PlacementCenter) {\n      return 0;\n    }\n\n    // if current placement fits and is prefered placement...\n    // return early\n    const placementsOnSameSide = this.filterPlacementsBySide(placement.primary);\n    const currentPlacementHasHighestPriority =\n      placementsOnSameSide.indexOf(placement) === 0;\n    if (currentPlacementHasHighestPriority && placement.fitsContainer) {\n      return 0;\n    }\n\n    const firstPlacementThatDoesNotFit = placementsOnSameSide.find(\n      placement => !placement.fitsContainer\n    );\n    if (!firstPlacementThatDoesNotFit) {\n      return 0;\n    }\n    const secondaryOffsetSide = firstPlacementThatDoesNotFit.secondaryOffsetSide!;\n    if (!secondaryOffsetSide) {\n      return 0;\n    }\n\n    const containerOffsets = placement.getContainerOffsets();\n\n    // determine whether we should add or substract the secondary-offset\n    const { secondary } = placement;\n    let factor: number;\n    if (\n      placement.triggerIsBigger ||\n      firstPlacementThatDoesNotFit === placement\n    ) {\n      factor = secondaryOffsetSide.isPush ? -1 : 1;\n    } else {\n      factor =\n        secondary === Side.left ||\n        ([Side.top, Side.center].includes(secondary) &&\n          secondaryOffsetSide.isPush)\n          ? -1\n          : 1;\n    }\n\n    // get number of pixels between placement that did not fit and current\n    // placement\n    const secondaryOffset = containerOffsets[secondaryOffsetSide!.prop];\n\n    return secondaryOffset * factor;\n  }\n\n  private getStyles(\n    layerBounds: Bounds,\n    placement: Placement,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ): Styles {\n    const layerStyleBase: CSSProperties = {\n      willChange: \"top, left, width, height\"\n    };\n\n    const arrow = getArrowStyle(\n      this.subjectsBounds.merge({ layer: layerBounds }),\n      placement,\n      this.config.arrowOffset\n    );\n\n    const layer: CSSProperties = this.config.overflowContainer\n      ? {\n          ...layerStyleBase,\n          position: \"fixed\",\n          top: layerBounds.top,\n          left: layerBounds.left\n        }\n      : {\n          ...layerStyleBase,\n          position: \"absolute\",\n          top:\n            layerBounds.top -\n            this.subjectsBounds.parent.top +\n            scrollOffsets.top -\n            borderOffsets.top,\n          left:\n            layerBounds.left -\n            this.subjectsBounds.parent.left +\n            scrollOffsets.left -\n            borderOffsets.left\n        };\n\n    return {\n      arrow,\n      layer\n    };\n  }\n\n  private getHasDisappeared(layerBounds: Bounds): DisappearType | null {\n    const subject = this.config.overflowContainer\n      ? this.subjectsBounds.trigger\n      : layerBounds;\n\n    const containerOffsets = BoundsOffsets.mergeSmallestSides(\n      this.subjectsBounds.offsetsToScrollContainers(subject, true)\n    );\n\n    const entries = (Object.entries(\n      containerOffsets.negativeSides\n    ) as unknown) as [BoundSideProp, number][];\n\n    const hasFullyDisappeared = entries.some(([prop, value]) => {\n      const side = BoundSide[prop];\n      return value <= -subject[side.sizeProp];\n    });\n\n    if (hasFullyDisappeared) {\n      return \"full\";\n    }\n\n    if (!containerOffsets.allSidesArePositive) {\n      return \"partial\";\n    }\n\n    return null;\n  }\n\n  public result(scrollOffsets: ScrollOffsets, borderOffsets: BorderOffsets) {\n    const suitablePlacement = this.findSuitablePlacement();\n    const secondaryOffset = this.getSecondaryOffset(suitablePlacement);\n    const layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);\n    const styles = this.getStyles(\n      layerBounds,\n      suitablePlacement,\n      scrollOffsets,\n      borderOffsets\n    );\n    const layerSide = suitablePlacement.primary.prop as SideProp;\n\n    return {\n      styles,\n      layerSide,\n      placement: suitablePlacement,\n      layerBounds,\n      hasDisappeared: this.getHasDisappeared(layerBounds)\n    };\n  }\n}\n","import { Bounds, IBounds, boundsToObject } from \"./Bounds\";\n\ninterface ISubjectsBounds {\n  trigger: IBounds;\n  layer: IBounds;\n  arrow: IBounds;\n  parent: IBounds;\n  window: IBounds;\n  scrollContainers: IBounds[];\n}\n\nexport class SubjectsBounds implements ISubjectsBounds {\n  public readonly trigger!: Bounds;\n  public readonly layer!: Bounds;\n  public readonly arrow!: Bounds;\n  public readonly parent!: Bounds;\n  public readonly window!: Bounds;\n  public readonly scrollContainers!: Bounds[];\n\n  private constructor(\n    subjectsBounds: ISubjectsBounds,\n    private readonly overflowContainer: boolean\n  ) {\n    Object.assign(this, subjectsBounds);\n  }\n\n  static create(\n    environment: Window,\n    layer: HTMLElement,\n    trigger: HTMLElement,\n    parent: HTMLElement | undefined,\n    arrow: HTMLElement | null,\n    scrollContainers: HTMLElement[],\n    overflowContainer: boolean,\n    getTriggerBounds?: () => IBounds\n  ) {\n    const window = Bounds.fromWindow(environment);\n\n    return new SubjectsBounds(\n      {\n        layer: Bounds.fromElement(layer, {\n          environment,\n          withTransform: false\n        }),\n        trigger: getTriggerBounds\n          ? Bounds.create(boundsToObject(getTriggerBounds()))\n          : Bounds.fromElement(trigger),\n        arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),\n        parent: parent ? Bounds.fromElement(parent) : window,\n        window,\n        scrollContainers: [\n          window,\n          ...scrollContainers.map(container =>\n            Bounds.fromElement(container, { withScrollbars: false })\n          )\n        ]\n      },\n      overflowContainer\n    );\n  }\n\n  merge(subjectsBounds: Partial<ISubjectsBounds>) {\n    return new SubjectsBounds(\n      {\n        ...this,\n        ...subjectsBounds\n      },\n      this.overflowContainer\n    );\n  }\n\n  get layerOffsetsToScrollContainers() {\n    return this.offsetsToScrollContainers(this.layer);\n  }\n\n  get triggerHasBiggerWidth() {\n    return this.trigger.width > this.layer.width;\n  }\n\n  get triggerHasBiggerHeight() {\n    return this.trigger.height > this.layer.height;\n  }\n\n  offsetsToScrollContainers(subject: Bounds, allContainers = false) {\n    const scrollContainers =\n      this.overflowContainer && !allContainers\n        ? [this.window]\n        : this.scrollContainers;\n\n    return scrollContainers.map(scrollContainer =>\n      scrollContainer.offsetsTo(subject)\n    );\n  }\n}\n","import {\n  useCallback,\n  useState,\n  useRef,\n  createElement,\n  ReactNode,\n  ReactPortal,\n  MutableRefObject,\n  CSSProperties,\n  useEffect\n} from \"react\";\nimport { createPortal } from \"react-dom\";\nimport warning from \"tiny-warning\";\nimport {\n  Options,\n  LayerSide,\n  Styles,\n  ScrollOffsets,\n  BorderOffsets,\n  PositionConfig,\n  RefCallback,\n  Container\n} from \"./types\";\nimport { useTrackElements, OnChangeElements } from \"./useTrackElements\";\nimport { useGroup, GroupProvider } from \"./useGroup\";\nimport { PlacementType, PLACEMENT_TYPES } from \"./PlacementType\";\nimport { Placements } from \"./Placements\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { useLastState } from \"./hooks\";\nimport { isSet, mergeRefs } from \"./util\";\n\nlet GLOBAL_CONTAINER: HTMLElement | null = null;\n\nexport function setGlobalContainer(container: Container) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  warning(\n    !(GLOBAL_CONTAINER instanceof HTMLElement),\n    `react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.`\n  );\n\n  if (typeof container === \"function\") {\n    GLOBAL_CONTAINER = container();\n  } else if (typeof container === \"string\") {\n    GLOBAL_CONTAINER = document.getElementById(container);\n  } else {\n    GLOBAL_CONTAINER = container;\n  }\n\n  warning(\n    GLOBAL_CONTAINER instanceof HTMLElement,\n    `react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element`\n  );\n}\n\nexport type LayerProps = { ref: RefCallback; style: Styles[\"layer\"] };\nexport type TriggerProps = { ref: RefCallback };\nexport type UseLayerArrowProps = {\n  ref: MutableRefObject<any> | RefCallback;\n  layerSide: LayerSide;\n  style: Styles[\"arrow\"];\n};\n\nexport type UseLayerProps = {\n  renderLayer: (children: ReactNode) => ReactPortal | null;\n  triggerProps: TriggerProps;\n  layerProps: LayerProps;\n  arrowProps: UseLayerArrowProps;\n  layerSide: LayerSide;\n  triggerBounds: ClientRect | null;\n};\n\ntype State = {\n  layerSide: LayerSide;\n  styles: Styles;\n};\n\nexport const DEFAULT_OPTIONS: Required<Omit<\n  Options,\n  | \"ResizeObserver\"\n  | \"environment\"\n  | \"onParentClose\"\n  | \"onOutsideClick\"\n  | \"onDisappear\"\n  | \"isOpen\"\n  | \"layerDimensions\"\n>> = {\n  auto: false,\n  arrowOffset: 0,\n  containerOffset: 10,\n  triggerOffset: 0,\n  overflowContainer: true,\n  placement: \"top-center\",\n  possiblePlacements: (PLACEMENT_TYPES as unknown) as PlacementType[],\n  preferX: \"right\",\n  preferY: \"bottom\",\n  snap: false,\n  container: undefined!,\n  trigger: undefined!\n};\n\nexport function useLayer({\n  isOpen = false,\n  overflowContainer = DEFAULT_OPTIONS.overflowContainer,\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ResizeObserver: ResizeObserverPolyfill,\n  placement = DEFAULT_OPTIONS.placement,\n  possiblePlacements = DEFAULT_OPTIONS.possiblePlacements,\n  preferX = DEFAULT_OPTIONS.preferX,\n  preferY = DEFAULT_OPTIONS.preferY,\n  auto = DEFAULT_OPTIONS.auto,\n  snap = DEFAULT_OPTIONS.snap,\n  triggerOffset = DEFAULT_OPTIONS.triggerOffset,\n  containerOffset = DEFAULT_OPTIONS.containerOffset,\n  arrowOffset = DEFAULT_OPTIONS.arrowOffset,\n  container = DEFAULT_OPTIONS.container,\n  layerDimensions = null,\n  onDisappear,\n  onOutsideClick,\n  onParentClose,\n  trigger: triggerOption\n}: Options): UseLayerProps {\n  // initialize styles\n  const [state, setState] = useState<State>(() => ({\n    layerSide:\n      placement === \"center\"\n        ? \"center\"\n        : Placements.getSidesFromPlacementType(placement)[0].prop,\n    styles: {\n      layer: {\n        position: overflowContainer ? \"fixed\" : \"absolute\",\n        top: 0,\n        left: 0\n      },\n      arrow: {\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      }\n    }\n  }));\n\n  const triggerBoundsRef = useRef<HTMLElement>(null!);\n\n  // tracks state in order for us to use read inside functions that require dependencies,\n  // like `useCallback`, without triggering an update\n  const lastState = useLastState(state, isOpen);\n\n  // keeps track of scheduled animation-frames\n  const raf = useRef<any>(null);\n  useEffect(() => {\n    return () => {\n      // when this hook unmounts, make sure to cancel any scheduled animation-frames\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = null;\n      }\n    };\n  }, []);\n\n  // Most important function regarding positioning\n  // It receives boundaries collected by `useTrackElements`, does some calculations,\n  // sets new styles, and handles when a layer has disappeared.\n  const handlePositioning = useCallback(\n    function handlePositioning(\n      { arrow, layer, scrollContainers, trigger }: OnChangeElements,\n      scrollOffsets: ScrollOffsets,\n      borderOffsets: BorderOffsets\n    ) {\n      const parent = scrollContainers[0];\n\n      const subjectsBounds = SubjectsBounds.create(\n        environment!,\n        layer,\n        trigger,\n        parent,\n        arrow,\n        scrollContainers,\n        overflowContainer,\n        triggerOption?.getBounds\n      );\n\n      const config: PositionConfig = {\n        placement,\n        possiblePlacements,\n        auto,\n        layerDimensions,\n        arrowOffset,\n        containerOffset,\n        triggerOffset,\n        preferX,\n        preferY,\n        snap,\n        overflowContainer\n      };\n\n      const { hasDisappeared, layerSide, styles } = Placements.create(\n        subjectsBounds,\n        config\n      ).result(scrollOffsets, borderOffsets);\n\n      const newState: State = {\n        layerSide,\n        styles\n      };\n\n      if (!lastState.current || didStateChange(lastState.current, newState)) {\n        lastState.current = newState; // optimistically update lastState to prevent infinite loop\n\n        /**\n         * We're using requestAnimationFrame-features here to ensure that position updates will\n         * happen max once per frame.\n         * If during a frame there's already an update scheduled, the existing update will be cancelled\n         * and the new update will take precedence.\n         */\n        if (raf.current) {\n          cancelAnimationFrame(raf.current);\n        }\n\n        raf.current = requestAnimationFrame(() => {\n          setState(newState);\n          raf.current = null;\n        });\n      }\n\n      if (isSet(hasDisappeared) && isSet(onDisappear)) {\n        onDisappear(hasDisappeared);\n      }\n    },\n    [\n      arrowOffset,\n      auto,\n      containerOffset,\n      environment,\n      layerDimensions,\n      onDisappear,\n      overflowContainer,\n      placement,\n      possiblePlacements,\n      preferX,\n      preferY,\n      snap,\n      triggerOffset,\n      lastState,\n      triggerOption\n    ]\n  );\n\n  const {\n    triggerRef,\n    layerRef,\n    arrowRef,\n    closestScrollContainer\n  } = useTrackElements({\n    ResizeObserverPolyfill,\n    environment,\n    enabled: isOpen,\n    overflowContainer,\n    onChange: handlePositioning,\n    triggerOption\n  });\n\n  const { closeOnOutsideClickRefs, registrations } = useGroup({\n    isOpen,\n    onOutsideClick,\n    onParentClose\n  });\n\n  const props: UseLayerProps = {\n    triggerProps: Boolean(triggerOption)\n      ? ({} as any) // when using the `trigger` option, make `triggerProps` useless\n      : {\n          ref: mergeRefs(\n            triggerRef,\n            closeOnOutsideClickRefs.trigger,\n            triggerBoundsRef\n          )\n        },\n    layerProps: {\n      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),\n      style: state.styles.layer\n    },\n    arrowProps: {\n      ref: arrowRef,\n      style: state.styles.arrow,\n      layerSide: state.layerSide\n    },\n    layerSide: state.layerSide,\n    triggerBounds: isOpen\n      ? triggerOption\n        ? triggerOption.getBounds()\n        : triggerBoundsRef.current?.getBoundingClientRect()\n      : null,\n    renderLayer: children =>\n      typeof document !== \"undefined\"\n        ? createPortal(\n            createElement(GroupProvider, { registrations, children }),\n            overflowContainer || !closestScrollContainer\n              ? getContainerElement(container)\n              : closestScrollContainer\n          )\n        : null\n  };\n\n  return props;\n}\n\nfunction didStateChange(previous: State, next: State): boolean {\n  if (previous.layerSide !== next.layerSide) {\n    return true;\n  }\n\n  const styleProps: Array<keyof CSSProperties> = [\n    \"position\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\"\n  ];\n  for (const prop of styleProps) {\n    if (\n      previous.styles.layer[prop] !== next.styles.layer[prop] ||\n      previous.styles.arrow[prop] !== next.styles.arrow[prop]\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst DEFAULT_CONTAINER_ID = \"layers\";\n\nfunction getContainerElement(container?: Container): HTMLElement {\n  let element: HTMLElement;\n\n  if (typeof container === \"function\") {\n    element = container();\n    if (!element || !(element instanceof HTMLElement)) {\n      throw new Error(\n        `react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (container instanceof HTMLElement) {\n    element = container;\n  } else if (typeof container === \"string\") {\n    element = document.getElementById(container)!;\n    if (!element) {\n      throw new Error(\n        `react-laag: You've passed element with id '${container}' to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {\n    return GLOBAL_CONTAINER;\n  } else {\n    element = document.getElementById(DEFAULT_CONTAINER_ID)!;\n    if (!element) {\n      element = document.createElement(\"div\");\n      element.id = DEFAULT_CONTAINER_ID;\n      element.style.cssText = `\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        right: 0px;\n      `;\n      document.body.appendChild(element);\n    }\n  }\n\n  return element;\n}\n","import { createElement, forwardRef } from \"react\";\nimport { BoundSide, BoundSideType } from \"./Sides\";\nimport { LayerSide } from \"./types\";\n\nconst LEFT = \"left\";\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst RIGHT = \"right\";\n\nfunction getWidthBasedOnAngle(angle: number, size: number) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  borderWidth: number\n) {\n  const map = {\n    [BOTTOM]: `0 ${-borderWidth} ${sizeB} ${sizeA}`,\n    [TOP]: `0 0 ${sizeB} ${sizeA + borderWidth}`,\n    [RIGHT]: `${-borderWidth} 0 ${sizeA} ${sizeB}`,\n    [LEFT]: `0 0 ${sizeA + borderWidth} ${sizeB}`\n  };\n\n  return map[side.prop];\n}\n\nfunction getTrianglePath(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  roundness: number,\n  angle: number\n) {\n  const relativeRoundness = (roundness / 10) * sizeA * 2;\n\n  const A = {\n    [BOTTOM]: [0, sizeA],\n    [TOP]: [0, 0],\n    [RIGHT]: [sizeA, sizeB],\n    [LEFT]: [0, sizeB]\n  }[side.prop].join(\" \");\n\n  const B = side.isHorizontal ? `V 0` : `H ${sizeB}`;\n\n  const cPoint = sizeB / 2;\n  const c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  const c1B = sizeA / 8;\n\n  const C = {\n    [BOTTOM]: [\"C\", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0],\n    [TOP]: [\n      \"C\",\n      c1A,\n      sizeA - c1B,\n      cPoint + relativeRoundness,\n      sizeA,\n      cPoint,\n      sizeA\n    ],\n    [RIGHT]: [\"C\", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint],\n    [LEFT]: [\n      \"C\",\n      sizeA - c1B,\n      sizeB - c1A,\n      sizeA,\n      cPoint - relativeRoundness,\n      sizeA,\n      cPoint\n    ]\n  }[side.prop].join(\" \");\n\n  const d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  const d1B = sizeA / 8;\n\n  const D = {\n    [BOTTOM]: [\"C\", cPoint - relativeRoundness, 0, d1A, d1B, A],\n    [TOP]: [\"C\", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A],\n    [RIGHT]: [\"C\", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A],\n    [LEFT]: [\n      \"C\",\n      sizeA,\n      cPoint + relativeRoundness,\n      sizeA - d1B,\n      sizeB - d1A,\n      A\n    ]\n  }[side.prop].join(\" \");\n\n  return [\"M\", A, B, C, D].join(\" \");\n}\n\nfunction getBorderMaskPath(\n  sizeA: number,\n  sizeB: number,\n  borderWidth: number,\n  side: BoundSideType,\n  angle: number\n) {\n  const borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  const [A, B] = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth];\n\n  if (side.isHorizontal) {\n    return [\n      \"M\",\n      A,\n      borderWidth,\n      \"V\",\n      sizeB - borderWidth,\n      \"L\",\n      B,\n      sizeB - borderWidth - borderOffset,\n      \"V\",\n      borderOffset + borderWidth,\n      \"Z\"\n    ].join(\" \");\n  }\n\n  return [\n    \"M\",\n    borderWidth,\n    A,\n    \"H\",\n    sizeB - borderWidth,\n    \"L\",\n    sizeB - borderWidth - borderOffset,\n    B,\n    \"H\",\n    borderOffset + borderWidth,\n    \"Z\"\n  ].join(\" \");\n}\n\nexport type ArrowProps = React.ComponentPropsWithoutRef<\"svg\"> & {\n  /**\n   * angle of triangle\n   * default is `45`\n   */\n  angle?: number;\n  /**\n   * distance in pixels between point of triangle and layer\n   * default is `8`\n   */\n  size?: number;\n  /**\n   * roundness of the point of the arrow\n   * range: 0 - 1\n   * default is `0`\n   */\n  roundness?: number;\n  /**\n   * width of the layers border\n   * default is `0`\n   */\n  borderWidth?: number;\n  /**\n   * color of the layers border\n   * default is `\"black\"`\n   */\n  borderColor?: string;\n  /**\n   * background-color of the layer\n   * default is `\"white\"`\n   */\n  backgroundColor?: string;\n  /**\n   * Given by `useLayer()` and determines the direction the arrow should\n   * be pointing to\n   */\n  layerSide?: LayerSide;\n};\n\nexport const Arrow = forwardRef<SVGSVGElement, ArrowProps>(function Arrow(\n  {\n    size = 8,\n    angle = 45,\n    borderWidth = 0,\n    borderColor = \"black\",\n    roundness = 0,\n    backgroundColor = \"white\",\n    layerSide = \"top\",\n    style = {},\n    ...rest\n  },\n  ref\n) {\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  const side = BoundSide[layerSide];\n  const sizeA = size;\n  const sizeB = getWidthBasedOnAngle(angle, size) * 2;\n\n  const maxSize = Math.max(sizeA, sizeB);\n\n  return createElement(\n    \"svg\",\n    {\n      ref,\n      ...rest,\n      style: {\n        ...style,\n        transform: `translate${side.isHorizontal ? \"Y\" : \"X\"}(-50%)`\n      },\n      width: maxSize,\n      height: maxSize,\n      preserveAspectRatio: side.isPush ? \"xMinYMin\" : \"xMaxYMax\",\n      viewBox: getViewBox(sizeA, sizeB, side, borderWidth)\n    },\n    createElement(\"path\", {\n      fill: backgroundColor,\n      strokeWidth: borderWidth,\n      stroke: borderColor,\n      d: getTrianglePath(sizeA, sizeB, side, roundness, angle)\n    }),\n    createElement(\"path\", {\n      fill: backgroundColor,\n      d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)\n    })\n  );\n});\n","import { useState, useRef, useCallback, useEffect, MouseEvent } from \"react\";\n\nexport type UseHoverOptions = {\n  /**\n   * Amount of milliseconds to wait while hovering before opening.\n   * Default is `0`\n   */\n  delayEnter?: number;\n  /**\n   * Amount of milliseconds to wait when mouse has left the trigger before closing.\n   * Default is `0`\n   */\n  delayLeave?: number;\n  /**\n   * Determines whether the layer should hide when the user starts scrolling.\n   * Default is `true`\n   */\n  hideOnScroll?: boolean;\n};\n\nexport type PlainCallback = (...args: any[]) => void;\n\nexport type UseHoverProps = {\n  onMouseEnter: PlainCallback;\n  onMouseLeave: PlainCallback;\n  onTouchStart: PlainCallback;\n  onTouchMove: PlainCallback;\n  onTouchEnd: PlainCallback;\n};\n\nenum Status {\n  ENTERING,\n  LEAVING,\n  IDLE\n}\n\nexport function useHover({\n  delayEnter = 0,\n  delayLeave = 0,\n  hideOnScroll = true\n}: UseHoverOptions = {}): readonly [boolean, UseHoverProps, () => void] {\n  const [show, setShow] = useState(false);\n\n  const timeout = useRef<number | null>(null);\n\n  const status = useRef<Status>(Status.IDLE);\n\n  const hasTouchMoved = useRef<boolean>(false);\n\n  const removeTimeout = useCallback(function removeTimeout() {\n    clearTimeout(timeout.current!);\n    timeout.current = null;\n    status.current = Status.IDLE;\n  }, []);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (status.current === Status.LEAVING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (show) {\n      return;\n    }\n\n    status.current = Status.ENTERING;\n    timeout.current = setTimeout(() => {\n      setShow(true);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayEnter);\n  }\n\n  function onMouseLeave(_: MouseEvent<any>, immediate?: boolean) {\n    // if was waiting for entering,\n    // clear timeout\n    if (status.current === Status.ENTERING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (!show) {\n      return;\n    }\n\n    if (immediate) {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n      return;\n    }\n\n    status.current = Status.LEAVING;\n    timeout.current = setTimeout(() => {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayLeave);\n  }\n\n  // make sure to clear timeout on unmount\n  useEffect(() => {\n    const currentTimeout = timeout.current;\n\n    function onScroll() {\n      if (show && hideOnScroll) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    function onTouchEnd() {\n      if (show) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n    window.addEventListener(\"touchend\", onTouchEnd, true);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n      window.removeEventListener(\"touchend\", onTouchEnd, true);\n\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n    };\n  }, [show, hideOnScroll, removeTimeout]);\n\n  const hoverProps: UseHoverProps = {\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart: () => {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: () => {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: () => {\n      if (!hasTouchMoved.current && !show) {\n        setShow(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n\n  return [show, hoverProps, () => onMouseLeave(null!, true)] as const;\n}\n","import { useState, useRef, useEffect } from \"react\";\n\nexport type TransitionProps = {\n  isOpen: boolean;\n  children: (\n    isOpen: boolean,\n    onTransitionEnd: any,\n    isLeaving: boolean\n  ) => React.ReactElement;\n};\n\n/**\n * @deprecated\n * Note: this component is marked as deprecated and will be removed and a possible\n * future release\n */\nexport function Transition({\n  isOpen: isOpenExternal,\n  children\n}: TransitionProps) {\n  const [state, setState] = useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  });\n\n  const didMount = useRef(false);\n\n  useEffect(() => {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n\n  useEffect(() => {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(\n    state.isOpenInternal,\n    () => {\n      if (!state.isOpenInternal) {\n        setState(s => ({ ...s, isLeaving: false }));\n      }\n    },\n    state.isLeaving\n  );\n}\n"],"names":["useTrackRef","onRefChange","storedReference","useRef","element","current","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","EMPTY_BOUNDS","top","left","right","bottom","width","height","getPixelValue","value","parseFloat","replace","limit","min","max","isSet","mergeRefs","refs","ref","createReferenceError","subject","GroupContext","createContext","GroupProvider","children","registrations","handleRegister","useCallback","registration","add","createElement","Provider","PLACEMENT_TYPES","OPPOSITES","center","SideBase","prop","opposite","isHorizontal","sizeProp","oppositeSizeProp","cssProp","oppositeCssProp","isCenter","isPush","factor","this","isOppositeDirection","side","createSide","recursive","includes","BoundSide","Side","SIDES","BoundsOffsets","offsets","Object","assign","mergeSmallestSides","boundsOffsets","first","rest","Error","result","fromEntries","map","boundsOffset","Math","every","_this","filter","_this2","sumOfPropertyValues","propertyValues","reduce","sum","propertyValue","boundsToObject","EMPTY","Bounds","bounds","create","fromElement","options","withTransform","environment","withScrollbars","getBoundingClientRect","getComputedStyle","boxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","substract","clientWidth","clientHeight","empty","fromWindow","innerWidth","innerHeight","toObject","merge","partialBoundsOrMergeFn","entries","boundSide","offsetsTo","child","mapSides","mapper","values","Placement","primary","secondary","subjectBounds","layerDimensions","setSubjectsBounds","dimensions","subjectsBounds","layer","getLayerBounds","secondaryOffset","_cachedLayerBounds","trigger","arrow","arrowOffsetBase","limitMin","limitMax","propertyA","propertyB","sec","triggerValue","layerBounds","getLayerCollisionBounds","container","getContainerOffsets","_cachedContainerOffsets","layerOffsetsToScrollContainers","triggerHasBiggerWidth","triggerHasBiggerHeight","allSidesArePositive","negativeSides","surface","containerOffsets","sort","_Object$entries$map$f2","PlacementCenter","STYLE_BASE","position","willChange","Placements","placements","config","getSidesFromPlacementType","type","split","b","arrowOffset","containerOffset","triggerOffset","getListOfPlacements","preferedPlacement","placement","preferredSide","preferY","preferX","triggerIsBigger","placementFrom","list","possiblePlacements","filterPlacementsBySide","findFirstPlacementThatFits","find","fitsContainer","placementWithBiggestVisibleSurface","visibleSurface","a","findSuitablePlacement","auto","getSecondaryOffset","snap","placementsOnSameSide","indexOf","firstPlacementThatDoesNotFit","secondaryOffsetSide","getStyles","scrollOffsets","borderOffsets","sizeProperty","negativeOffset","sideA","sideB","offsetA","offsetB","getNegativeOffsetBetweenLayerCenterAndTrigger","secondarySide","secondaryValue","getArrowStyle","overflowContainer","parent","getHasDisappeared","offsetsToScrollContainers","some","suitablePlacement","styles","layerSide","hasDisappeared","SubjectsBounds","scrollContainers","getTriggerBounds","allContainers","scrollContainer","GLOBAL_CONTAINER","DEFAULT_OPTIONS","undefined","getWidthBasedOnAngle","angle","size","tan","PI","getViewBox","sizeA","sizeB","borderWidth","getTrianglePath","roundness","relativeRoundness","A","join","B","cPoint","c1A","c1B","C","d1A","d1B","getBorderMaskPath","borderOffset","Status","Arrow","forwardRef","borderColor","backgroundColor","style","maxSize","transform","preserveAspectRatio","viewBox","fill","strokeWidth","stroke","d","isOpenExternal","isOpen","useState","isOpenInternal","isLeaving","state","setState","didMount","s","document","getElementById","delayEnter","delayLeave","hideOnScroll","show","setShow","timeout","status","IDLE","hasTouchMoved","removeTimeout","clearTimeout","onMouseLeave","_","immediate","ENTERING","LEAVING","setTimeout","currentTimeout","onScroll","onTouchEnd","addEventListener","removeEventListener","onMouseEnter","onTouchStart","onTouchMove","ResizeObserverPolyfill","ResizeObserver","onDisappear","onOutsideClick","onParentClose","triggerOption","triggerBoundsRef","lastState","currentState","enabled","useLastState","raf","cancelAnimationFrame","handlePositioning","getBounds","newState","previous","next","didStateChange","requestAnimationFrame","onChange","polyfill","getResizeObserver","subscriptions","arrowRef","hasTriggerOption","Boolean","useMemo","setter","get","set","hasEventSubscriptions","length","removeAllEventSubscriptions","unsubscribe","addEventSubscription","unsubscriber","push","handleChange","closestScrollContainer","scrollTop","scrollLeft","scrollY","scrollX","borderTopWidth","borderLeftWidth","addEventListeners","ignoredInitialCall","observer","body","observe","unobserve","disconnect","resetWhenReferenceChangedWhileTracking","layerRef","previousLayer","getScrollContainers","findScrollContainers","overflow","overflowX","overflowY","parentElement","triggerRef","previousTrigger","triggerOptionParent","getParent","useTrackElements","Set","possibleRegisterFn","useContext","shouldCloseWhenClickedOutside","event","target","clickedOnTrigger","contains","clickedOnLayer","shouldCloseAccordingToChildren","getShouldCloseAccordingToChildren","forEach","closeChild","handleClick","closeOnOutsideClickRefs","useGroup","triggerProps","layerProps","arrowProps","triggerBounds","_triggerBoundsRef$cur","renderLayer","createPortal","HTMLElement","id","cssText","appendChild","getContainerElement","preventDefault","parentRef","mouseBounds","setMouseBounds","hasMousePosition","resetMousePosition","handleMouseEvent","evt","clientX","clientY"],"mappings":"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"}