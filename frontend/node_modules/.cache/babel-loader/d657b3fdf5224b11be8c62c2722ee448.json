{"ast":null,"code":"import { useRef, useState, useMemo, useLayoutEffect, useEffect, useCallback, createElement, useContext, createContext, forwardRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport warning from 'tiny-warning';\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n/**\r\n * Utility hook to track the reference of a html-element.\r\n * It notifies the listener when a change occured, so it can act\r\n * on the change\r\n */\n\n\nfunction useTrackRef(onRefChange) {\n  var storedReference = useRef(null); // this is de function that actually gets passed to the `ref` prop\n  // on the html element. I.e.:\n  // <div ref={setter} />\n\n  function setter(element) {\n    if (!element || element === storedReference.current) {\n      return;\n    }\n\n    storedReference.current = element;\n    onRefChange(element);\n  }\n\n  return setter;\n}\n/**\r\n * Utility hook that stores mutable state.\r\n * Since a getter function is used, it will always return the most\r\n * up-to-date state. This is useful when you want to get certain state within\r\n * an effect, without triggering the same effect when the same state changes.\r\n * Note: may be seen as an anti-pattern.\r\n */\n\n\nfunction useMutableStore(initialState) {\n  var state = useRef(initialState);\n  return useMemo(function () {\n    function set(setter) {\n      if (typeof setter === \"function\") {\n        state.current = setter(state.current);\n      } else {\n        state.current = setter;\n      }\n    }\n\n    function get() {\n      return state.current;\n    }\n\n    return [get, set];\n  }, []);\n}\n/**\r\n * Utility hook that keeps track of active event listeners and how\r\n * to remove these listeners\r\n */\n\n\nfunction useEventSubscriptions() {\n  var subscriptions = useRef([]);\n  return useMemo(function () {\n    function hasEventSubscriptions() {\n      return subscriptions.current.length > 0;\n    }\n\n    function removeAllEventSubscriptions() {\n      for (var _iterator = _createForOfIteratorHelperLoose(subscriptions.current), _step; !(_step = _iterator()).done;) {\n        var unsubscribe = _step.value;\n        unsubscribe();\n      }\n\n      subscriptions.current = [];\n    }\n\n    function addEventSubscription(unsubscriber) {\n      subscriptions.current.push(unsubscriber);\n    }\n\n    return {\n      hasEventSubscriptions: hasEventSubscriptions,\n      removeAllEventSubscriptions: removeAllEventSubscriptions,\n      addEventSubscription: addEventSubscription\n    };\n  }, []);\n}\n/**\r\n * SSR-safe effect hook\r\n */\n\n\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n/**\r\n * Utility hook that tracks an state object.\r\n * If `enabled=false` it will discard changes and reset the lastState to `null`\r\n */\n\nfunction useLastState(currentState, enabled) {\n  var lastState = useRef(currentState);\n\n  if (!enabled) {\n    lastState.current = null;\n    return lastState;\n  }\n\n  lastState.current = currentState;\n  return lastState;\n}\n\nvar EMPTY_BOUNDS = {\n  top: 0,\n  left: 0,\n  right: 1,\n  bottom: 1,\n  width: 1,\n  height: 1\n};\n/**\r\n * @description Utility hook that lets you use the mouse-position as source of the trigger.\r\n * This is useful in scenario's like context-menu's.\r\n *\r\n * @example\r\n * ```tsx\r\n * const {\r\n *  hasMousePosition,\r\n *  resetMousePosition,\r\n *  handleMouseEvent,\r\n *  trigger\r\n *  } = useMousePositionAsTrigger();\r\n *\r\n * const { renderLayer, layerProps } = useLayer({\r\n *  isOpen: hasMousePosition,\r\n *  trigger,\r\n *  onOutsideClick: resetMousePosition\r\n * });\r\n *\r\n * return (\r\n *  <>\r\n *   {isOpen && renderLayer(<div {...layerProps} />)}\r\n *   <div onContextMenu={handleMouseEvent} />\r\n *  </>\r\n * );\r\n * ```\r\n */\n\nfunction useMousePositionAsTrigger(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$enabled = _ref.enabled,\n      enabled = _ref$enabled === void 0 ? true : _ref$enabled,\n      _ref$preventDefault = _ref.preventDefault,\n      preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault;\n\n  var parentRef = useRef(null);\n\n  var _useState = useState(EMPTY_BOUNDS),\n      mouseBounds = _useState[0],\n      setMouseBounds = _useState[1];\n\n  function resetMousePosition() {\n    setMouseBounds(EMPTY_BOUNDS);\n  }\n\n  var hasMousePosition = mouseBounds !== EMPTY_BOUNDS;\n\n  function handleMouseEvent(evt) {\n    if (!enabled) {\n      return;\n    }\n\n    if (preventDefault) {\n      evt.preventDefault();\n    }\n\n    var left = evt.clientX,\n        top = evt.clientY;\n    setMouseBounds({\n      top: top,\n      left: left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      bottom: top + 1\n    });\n  }\n\n  return {\n    hasMousePosition: hasMousePosition,\n    resetMousePosition: resetMousePosition,\n    handleMouseEvent: handleMouseEvent,\n    trigger: {\n      getBounds: function getBounds() {\n        return mouseBounds;\n      },\n      getParent: parentRef.current ? function () {\n        return parentRef.current;\n      } : undefined\n    },\n    parentRef: parentRef\n  };\n}\n/**\r\n * Convert a pixel value into a numeric value\r\n * @param value string value (ie. '12px')\r\n */\n\n\nfunction getPixelValue(value) {\n  return parseFloat(value.replace(\"px\", \"\"));\n}\n/**\r\n * Returns a numeric value that doesn't exceed min or max\r\n */\n\n\nfunction limit(value, min, max) {\n  return value < min ? min : value > max ? max : value;\n}\n/**\r\n * Utility function which ensures whether a value is truthy\r\n */\n\n\nfunction isSet(value) {\n  return value === null || value === undefined ? false : true;\n}\n/**\r\n * Utility function that let's you assign multiple references to a 'ref' prop\r\n * @param refs list of MutableRefObject's and / or callbacks\r\n */\n\n\nfunction mergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return function (element) {\n    for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done;) {\n      var ref = _step.value;\n\n      if (!ref) {\n        continue;\n      }\n\n      if (typeof ref === \"function\") {\n        ref(element);\n      } else {\n        ref.current = element;\n      }\n    }\n  };\n}\n/**\r\n * Utility to get the correct ResizeObserver class\r\n */\n\n\nfunction getResizeObserver(environment, polyfill) {\n  if (typeof environment === \"undefined\") {\n    return undefined;\n  }\n\n  return polyfill || environment.ResizeObserver;\n}\n/**\r\n * Utility function that given a element traverses up in the html-hierarchy\r\n * to find and return all ancestors that have scroll behavior\r\n */\n\n\nfunction findScrollContainers(element, environment) {\n  var result = [];\n\n  if (!element || !environment || element === document.body) {\n    return result;\n  }\n\n  var _environment$getCompu = environment.getComputedStyle(element),\n      overflow = _environment$getCompu.overflow,\n      overflowX = _environment$getCompu.overflowX,\n      overflowY = _environment$getCompu.overflowY;\n\n  if ([overflow, overflowX, overflowY].some(function (prop) {\n    return [\"auto\", \"scroll\"].includes(prop);\n  })) {\n    result.push(element);\n  }\n\n  return [].concat(result, findScrollContainers(element.parentElement, environment));\n}\n\nfunction createReferenceError(subject) {\n  return \"react-laag: Could not find a valid reference for the \" + subject + \" element. There might be 2 causes:\\n   - Make sure that the 'ref' is set correctly on the \" + subject + \" element when isOpen: true. Also make sure your component forwards the ref with \\\"forwardRef()\\\".\\n   - Make sure that you are actually rendering the \" + subject + \" when the isOpen prop is set to true\";\n}\n/**\r\n * This hook has the responsibility to track the bounds of:\r\n * - the trigger element\r\n * - the layer element\r\n * - the arrow element\r\n * - the scroll-containers of which the trigger element is a descendant of\r\n *\r\n * It will call the `onChange` callback with a collection of these elements when any\r\n * of the tracked elements bounds have changed\r\n *\r\n * It will detect these changes by listening:\r\n * - when the reference of the trigger element changes\r\n * - when the reference of the layer element changes\r\n * - when the trigger, layer or document body changes in size\r\n * - when the user scrolls the page, or any of the scroll containers\r\n */\n\n\nfunction useTrackElements(_ref) {\n  var enabled = _ref.enabled,\n      onChange = _ref.onChange,\n      environment = _ref.environment,\n      ResizeObserverPolyfill = _ref.ResizeObserverPolyfill,\n      overflowContainer = _ref.overflowContainer,\n      triggerOption = _ref.triggerOption; // get the correct reference to the ResizeObserver class\n\n  var ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill); // warn the user when no valid ResizeObserver class could be found\n\n  useEffect(function () {\n    process.env.NODE_ENV !== \"production\" ? warning(ResizeObserver, \"This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://link\") : void 0;\n  }, [ResizeObserver]); // keep reference of the optional arrow-component\n\n  var arrowRef = useRef(null); // if user has provided the trigger-option we should ingore certain things elsewhere\n\n  var hasTriggerOption = Boolean(triggerOption); // Keep track of mutable element related state\n  // It is generally better to use React.useState, but unfortunately that causes to many re-renders\n\n  var _useMutableStore = useMutableStore({\n    scrollContainers: [],\n    trigger: null,\n    layer: null\n  }),\n      get = _useMutableStore[0],\n      set = _useMutableStore[1]; // utility to keep track of the scroll and resize listeners and how to unsubscribe them\n\n\n  var _useEventSubscription = useEventSubscriptions(),\n      hasEventSubscriptions = _useEventSubscription.hasEventSubscriptions,\n      addEventSubscription = _useEventSubscription.addEventSubscription,\n      removeAllEventSubscriptions = _useEventSubscription.removeAllEventSubscriptions; // All scroll and resize changes eventually end up here, where the collection of bounds (subjectsBounds) is\n  // constructed in order to notifiy the `onBoundsChange` callback\n\n\n  var handleChange = useCallback(function handleChange() {\n    var _get = get(),\n        layer = _get.layer,\n        trigger = _get.trigger,\n        scrollContainers = _get.scrollContainers;\n\n    var closestScrollContainer = scrollContainers[0];\n\n    if (!layer) {\n      throw new Error(createReferenceError(\"layer\"));\n    } // ignore when user has provided the trigger-option\n\n\n    if (!trigger && !hasTriggerOption) {\n      throw new Error(createReferenceError(\"trigger\"));\n    }\n\n    var scrollOffsets = {\n      top: 0,\n      left: 0\n    };\n\n    if (closestScrollContainer) {\n      var scrollLeft = closestScrollContainer.scrollLeft,\n          scrollTop = closestScrollContainer.scrollTop;\n      scrollOffsets = {\n        top: scrollTop,\n        left: scrollLeft\n      };\n    } else {\n      var scrollX = environment.scrollX,\n          scrollY = environment.scrollY;\n      scrollOffsets = {\n        top: scrollY,\n        left: scrollX\n      };\n    }\n\n    var borderOffsets = {\n      left: 0,\n      top: 0\n    };\n\n    if (closestScrollContainer) {\n      var _environment$getCompu2 = environment.getComputedStyle(closestScrollContainer),\n          borderLeftWidth = _environment$getCompu2.borderLeftWidth,\n          borderTopWidth = _environment$getCompu2.borderTopWidth;\n\n      borderOffsets = {\n        left: getPixelValue(borderLeftWidth) || 0,\n        top: getPixelValue(borderTopWidth) || 0\n      };\n    }\n\n    onChange({\n      layer: layer,\n      trigger: trigger,\n      scrollContainers: scrollContainers,\n      arrow: arrowRef.current\n    }, scrollOffsets, borderOffsets);\n  }, [get, onChange, environment, arrowRef, hasTriggerOption]); // responsible for adding the scroll and resize listeners to the correct\n  // html elements\n\n  var addEventListeners = useCallback(function addEventListeners() {\n    var _get2 = get(),\n        trigger = _get2.trigger,\n        layer = _get2.layer,\n        scrollContainers = _get2.scrollContainers;\n\n    if (!layer) {\n      throw new Error(createReferenceError(\"layer\"));\n    }\n\n    if (!trigger && !hasTriggerOption) {\n      // ignore when user has provided the trigger-option\n      throw new Error(createReferenceError(\"trigger\"));\n    }\n\n    if (ResizeObserver) {\n      var ignoredInitialCall = false;\n\n      var observerCallback = function observerCallback() {\n        if (!ignoredInitialCall) {\n          ignoredInitialCall = true;\n          return;\n        }\n\n        handleChange();\n      };\n\n      var observer = new ResizeObserver(observerCallback);\n\n      for (var _i = 0, _arr = [trigger, layer, document.body]; _i < _arr.length; _i++) {\n        var element = _arr[_i];\n        if (element) observer.observe(element);\n      }\n\n      addEventSubscription(function () {\n        for (var _i2 = 0, _arr2 = [trigger, layer, document.body]; _i2 < _arr2.length; _i2++) {\n          var _element = _arr2[_i2];\n          if (_element) observer.unobserve(_element);\n        }\n\n        observer.disconnect();\n      });\n    }\n\n    var listenForScrollElements = [environment].concat(scrollContainers);\n\n    var _loop = function _loop() {\n      var element = _step.value;\n      element.addEventListener(\"scroll\", handleChange);\n      addEventSubscription(function () {\n        return element.removeEventListener(\"scroll\", handleChange);\n      });\n    };\n\n    for (var _iterator = _createForOfIteratorHelperLoose(listenForScrollElements), _step; !(_step = _iterator()).done;) {\n      _loop();\n    }\n  }, [get, addEventSubscription, handleChange, environment, ResizeObserver, hasTriggerOption]); // when either the reference to the trigger or layer element changes\n  // we should reset the event listeners and trigger a `onChange`\n\n  var resetWhenReferenceChangedWhileTracking = useCallback(function (previous, next) {\n    if (enabled && previous && previous !== next) {\n      removeAllEventSubscriptions();\n      addEventListeners();\n      handleChange();\n    }\n  }, [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]); // Logic when reference to layer changes\n\n  var layerRef = useTrackRef(useCallback(function (layer) {\n    var _get3 = get(),\n        previousLayer = _get3.layer; // store new reference\n\n\n    set(function (state) {\n      return _extends({}, state, {\n        layer: layer\n      });\n    }); // check if we should reset the event listeners\n\n    resetWhenReferenceChangedWhileTracking(previousLayer, layer);\n  }, [get, set, resetWhenReferenceChangedWhileTracking]));\n  var getScrollContainers = useCallback(function handleScrollContainers(element) {\n    var scrollContainers = findScrollContainers(element, environment);\n    var closestScrollContainer = scrollContainers[0];\n\n    if (closestScrollContainer) {\n      // Check if we should warn the user about 'position: relative; stuff...'\n      var position = environment.getComputedStyle(closestScrollContainer).position;\n      var closestScrollContainerHasCorrectStyling = [\"relative\", \"absolute\", \"fixed\"].includes(position) || overflowContainer;\n\n      if (!closestScrollContainerHasCorrectStyling) {\n        closestScrollContainer.style.position = \"relative\";\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(closestScrollContainerHasCorrectStyling, \"react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: \\\"\" + position + \"\\\". For now, \\\"position: relative;\\\" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.\") : void 0;\n    }\n\n    return scrollContainers;\n  }, [environment, overflowContainer]); // Logic when reference to trigger changes\n  // Note: this will have no effect when user provided the trigger-option\n\n  var triggerRef = useTrackRef(useCallback(function (trigger) {\n    // collect list of scroll containers\n    var scrollContainers = getScrollContainers(trigger);\n\n    var _get4 = get(),\n        previousTrigger = _get4.trigger; // store new references\n\n\n    set(function (state) {\n      return _extends({}, state, {\n        trigger: trigger,\n        scrollContainers: scrollContainers\n      });\n    }); // check if we should reset the event listeners\n\n    resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);\n  }, [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers])); // when user has provided the trigger-option, it monitors the optional parent-element\n  // in order to determine the scroll-containers\n\n  var triggerOptionParent = triggerOption == null ? void 0 : triggerOption.getParent == null ? void 0 : triggerOption.getParent();\n  useIsomorphicLayoutEffect(function () {\n    if (!triggerOptionParent) {\n      return;\n    }\n\n    set(function (state) {\n      return _extends({}, state, {\n        scrollContainers: getScrollContainers(triggerOptionParent)\n      });\n    });\n  }, [triggerOptionParent, set, getScrollContainers]);\n  useIsomorphicLayoutEffect(function () {\n    if (enabled) {\n      // add event listeners if necessary\n      if (!hasEventSubscriptions()) {\n        addEventListeners();\n      }\n    }\n\n    return function () {\n      if (hasEventSubscriptions()) {\n        removeAllEventSubscriptions();\n      }\n    };\n  }, [enabled, hasEventSubscriptions, addEventListeners, removeAllEventSubscriptions]); // run this effect after every render\n\n  useIsomorphicLayoutEffect(function () {\n    if (enabled) {\n      // eventually call `handleChange` with latest elements-refs\n      handleChange();\n    }\n  });\n  return {\n    triggerRef: triggerRef,\n    layerRef: layerRef,\n    arrowRef: arrowRef,\n    closestScrollContainer: get().scrollContainers[0] || null\n  };\n}\n\nvar GroupContext = /*#__PURE__*/createContext({}); // Provider that wraps arround the layer in order to provide other useLayers\n// down in the hiearchy (child layers) with means to communicate with the parent.\n// This provider receives a `registrations` Set which can be used to add and\n// delete registrations.\n\nfunction GroupProvider(_ref) {\n  var children = _ref.children,\n      registrations = _ref.registrations; // registration function that is used as 'context payload' for child layers\n  // to call. It returns a function to unregister.\n\n  var handleRegister = useCallback(function register(registration) {\n    registrations.current.add(registration);\n    return function () {\n      return registrations.current[\"delete\"](registration);\n    };\n  }, [registrations]);\n  return createElement(GroupContext.Provider, {\n    value: handleRegister\n  }, children);\n} // asks child layers if they would close given the documents click event\n// if there's one that signals not to close, return early (false)\n\n\nfunction getShouldCloseAccordingToChildren(registrations, event) {\n  for (var _iterator = _createForOfIteratorHelperLoose(registrations), _step; !(_step = _iterator()).done;) {\n    var shouldCloseWhenClickedOutside = _step.value.shouldCloseWhenClickedOutside;\n\n    if (!shouldCloseWhenClickedOutside(event)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Responsible for close behavior\r\n * When the `onOutsideClick` callback is provided by the user, it will listen for clicks\r\n * in the document, and tell whether the user clicked outside -> not on layer / trigger.\r\n * It keeps track of nested useLayers a.k.a child layers (`registrations` Set), through which\r\n * we can ask whether they `shouldCloseWhenClickedOutside`, or tell them to close.\r\n *\r\n * Behavior:\r\n * - `onOutsideClick` only works on the most outer parent, and not on children. The parent will ask\r\n *   the child layers whether they would close, and will handle accordingly. The parent may\r\n *   command the children to close indirectly with the help of `onParentClose`\r\n * - When the parent just was closed, it will make sure that any children will also close\r\n *   with the help of `onParentClose`\r\n */\n\n\nfunction useGroup(_ref2) {\n  var isOpen = _ref2.isOpen,\n      onOutsideClick = _ref2.onOutsideClick,\n      onParentClose = _ref2.onParentClose; // store references to the dom-elements\n  // we need these to later determine wether the clicked outside or not\n\n  var trigger = useRef(null);\n  var layer = useRef(null); // a Set which keeps track of callbacks given by the child layers through context\n\n  var registrations = useRef(new Set()); // if this instance is a child itself, we should use this function to register\n  // some callbacks to the parent\n\n  var possibleRegisterFn = useContext(GroupContext); // recursively checks whether to close or not. This mechanism has some similarities\n  // with event bubbling.\n\n  var shouldCloseWhenClickedOutside = useCallback(function shouldCloseWhenClickedOutside(event) {\n    var target = event.target;\n    var clickedOnTrigger = trigger.current && trigger.current.contains(target);\n    var clickedOnLayer = layer.current && layer.current.contains(target);\n    var shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(registrations.current, event); // when clicked on own layer, but the child would have closed ->\n    // let child close\n\n    if (clickedOnLayer && shouldCloseAccordingToChildren) {\n      registrations.current.forEach(function (_ref3) {\n        var closeChild = _ref3.closeChild;\n        return closeChild();\n      });\n    }\n\n    return !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren;\n  }, [trigger, layer, registrations]); // registration stuff\n\n  useEffect(function () {\n    if (typeof possibleRegisterFn !== \"function\") {\n      return;\n    } // 'possibleRegisterFn' will return a function that will unregister\n    // on cleanup\n\n\n    return possibleRegisterFn({\n      shouldCloseWhenClickedOutside: shouldCloseWhenClickedOutside,\n      closeChild: function closeChild() {\n        process.env.NODE_ENV !== \"production\" ? warning(onParentClose, \"react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.\") : void 0;\n\n        if (onParentClose) {\n          onParentClose();\n        }\n      }\n    });\n  }, [possibleRegisterFn, shouldCloseWhenClickedOutside, onParentClose, registrations]); // document click handling\n\n  useEffect(function () {\n    var isChild = typeof possibleRegisterFn === \"function\";\n    var shouldNotListen = !isOpen || !onOutsideClick || isChild;\n\n    if (shouldNotListen) {\n      return;\n    }\n\n    function handleClick(event) {\n      if (shouldCloseWhenClickedOutside(event)) {\n        onOutsideClick();\n      }\n    }\n\n    document.addEventListener(\"click\", handleClick, true);\n    return function () {\n      return document.removeEventListener(\"click\", handleClick, true);\n    };\n  }, [isOpen, onOutsideClick, shouldCloseWhenClickedOutside, possibleRegisterFn]); // When this 'useLayer' gets closed -> tell child layers to close as well\n\n  useEffect(function () {\n    if (!isOpen) {\n      registrations.current.forEach(function (_ref4) {\n        var closeChild = _ref4.closeChild;\n        return closeChild();\n      });\n    }\n  }, [isOpen]);\n  return {\n    closeOnOutsideClickRefs: {\n      trigger: trigger,\n      layer: layer\n    },\n    registrations: registrations\n  };\n}\n\nvar PLACEMENT_TYPES = [\"bottom-start\", \"bottom-end\", \"bottom-center\", \"top-start\", \"top-center\", \"top-end\", \"left-end\", \"left-center\", \"left-start\", \"right-end\", \"right-center\", \"right-start\", \"center\"];\nvar OPPOSITES = {\n  top: \"bottom\",\n  left: \"right\",\n  bottom: \"top\",\n  right: \"left\",\n  center: \"center\"\n};\n\nvar SideBase = /*#__PURE__*/function () {\n  function SideBase(prop, opposite, isHorizontal, sizeProp, oppositeSizeProp, cssProp, oppositeCssProp, isCenter, isPush // left | top\n  ) {\n    this.prop = prop;\n    this.opposite = opposite;\n    this.isHorizontal = isHorizontal;\n    this.sizeProp = sizeProp;\n    this.oppositeSizeProp = oppositeSizeProp;\n    this.cssProp = cssProp;\n    this.oppositeCssProp = oppositeCssProp;\n    this.isCenter = isCenter;\n    this.isPush = isPush;\n  }\n\n  var _proto = SideBase.prototype;\n\n  _proto.factor = function factor(value) {\n    return value * (this.isPush ? 1 : -1);\n  };\n\n  _proto.isOppositeDirection = function isOppositeDirection(side) {\n    return this.isHorizontal !== side.isHorizontal;\n  };\n\n  return SideBase;\n}();\n\nfunction createSide(prop, recursive) {\n  if (recursive === void 0) {\n    recursive = true;\n  }\n\n  var isHorizontal = [\"left\", \"right\"].includes(prop);\n  return new SideBase(prop, recursive ? createSide(OPPOSITES[prop], false) : null, isHorizontal, isHorizontal ? \"width\" : \"height\", isHorizontal ? \"height\" : \"width\", isHorizontal ? \"left\" : \"top\", isHorizontal ? \"top\" : \"left\", prop === \"center\", ![\"right\", \"bottom\"].includes(prop));\n}\n\nvar BoundSide = {\n  top: /*#__PURE__*/createSide(\"top\"),\n  bottom: /*#__PURE__*/createSide(\"bottom\"),\n  left: /*#__PURE__*/createSide(\"left\"),\n  right: /*#__PURE__*/createSide(\"right\")\n};\n\nvar Side = /*#__PURE__*/_extends({}, BoundSide, {\n  center: /*#__PURE__*/createSide(\"center\")\n});\n\nvar SIDES = [\"top\", \"left\", \"bottom\", \"right\"];\n/**\r\n * A class containing the positional properties which represent the distance\r\n * between two Bounds instances for each side\r\n */\n\nvar BoundsOffsets = /*#__PURE__*/function () {\n  function BoundsOffsets(offsets) {\n    return Object.assign(this, offsets);\n  }\n  /**\r\n   * Takes multiple BoundsOffets instances and creates a new BoundsOffsets instance\r\n   * by taking the smallest value for each side\r\n   * @param boundsOffsets list of BoundsOffsets instances\r\n   */\n\n\n  BoundsOffsets.mergeSmallestSides = function mergeSmallestSides(boundsOffsets) {\n    var first = boundsOffsets[0],\n        rest = boundsOffsets.slice(1);\n\n    if (!first) {\n      throw new Error(\"Please provide at least 1 bounds objects in order to merge\");\n    }\n\n    var result = Object.fromEntries(SIDES.map(function (side) {\n      return [side, first[side]];\n    }));\n\n    for (var _iterator = _createForOfIteratorHelperLoose(rest), _step; !(_step = _iterator()).done;) {\n      var boundsOffset = _step.value;\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(SIDES), _step2; !(_step2 = _iterator2()).done;) {\n        var side = _step2.value;\n        result[side] = Math.min(result[side], boundsOffset[side]);\n      }\n    }\n\n    return new BoundsOffsets(result);\n  }\n  /**\r\n   * Checks whether all sides sides are positive, meaning the corresponding Bounds instance\r\n   * fits perfectly within a parent Bounds instance\r\n   */\n  ;\n\n  _createClass(BoundsOffsets, [{\n    key: \"allSidesArePositive\",\n    get: function get() {\n      var _this = this;\n\n      return SIDES.every(function (side) {\n        return _this[side] >= 0;\n      });\n    }\n    /**\r\n     * Returns a partial IBoundsOffsets with sides that are negative, meaning sides aren't entirely\r\n     * visible in respect to a parent Bounds instance\r\n     */\n\n  }, {\n    key: \"negativeSides\",\n    get: function get() {\n      var _this2 = this;\n\n      return Object.fromEntries(SIDES.filter(function (side) {\n        return _this2[side] < 0;\n      }).map(function (side) {\n        return [side, _this2[side]];\n      }));\n    }\n  }]);\n\n  return BoundsOffsets;\n}();\n/**\r\n * Utility function that returns sum of various computed styles\r\n * @param propertyValues list of computed styles (ie. '12px')\r\n */\n\n\nfunction sumOfPropertyValues() {\n  for (var _len = arguments.length, propertyValues = new Array(_len), _key = 0; _key < _len; _key++) {\n    propertyValues[_key] = arguments[_key];\n  }\n\n  return propertyValues.reduce(function (sum, propertyValue) {\n    return sum + (propertyValue ? getPixelValue(propertyValue) : 0);\n  }, 0);\n}\n\nfunction boundsToObject(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      right = _ref.right,\n      bottom = _ref.bottom,\n      width = _ref.width,\n      height = _ref.height;\n  return {\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom,\n    width: width,\n    height: height\n  };\n}\n\nvar EMPTY = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: 0,\n  height: 0\n};\n/**\r\n * A class containing the positional properties of the native DOM's ClientRect\r\n * (`element.getBoundingClientRect()`), together with some utility methods\r\n */\n\nvar Bounds = /*#__PURE__*/function () {\n  function Bounds(bounds) {\n    if (bounds === void 0) {\n      bounds = {};\n    }\n\n    return Object.assign(this, EMPTY, bounds);\n  }\n  /**\r\n   * Creates a new Bounds class\r\n   * @param bounds An object that adheres to the `IBounds` interface\r\n   */\n\n\n  Bounds.create = function create(bounds) {\n    return new Bounds(bounds);\n  }\n  /**\r\n   * Creates a new Bounds class from a DOM-element\r\n   * @param element reference to the DOM-element\r\n   * @param options optional options object\r\n   */\n  ;\n\n  Bounds.fromElement = function fromElement(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        _options$withTransfor = _options.withTransform,\n        withTransform = _options$withTransfor === void 0 ? true : _options$withTransfor,\n        _options$environment = _options.environment,\n        environment = _options$environment === void 0 ? window : _options$environment,\n        _options$withScrollba = _options.withScrollbars,\n        withScrollbars = _options$withScrollba === void 0 ? true : _options$withScrollba;\n    var plain = boundsToObject(element.getBoundingClientRect());\n    var bounds = new Bounds(plain);\n\n    if (!withTransform) {\n      var _environment$getCompu = environment.getComputedStyle(element),\n          width = _environment$getCompu.width,\n          height = _environment$getCompu.height,\n          boxSizing = _environment$getCompu.boxSizing,\n          borderLeft = _environment$getCompu.borderLeft,\n          borderRight = _environment$getCompu.borderRight,\n          borderTop = _environment$getCompu.borderTop,\n          borderBottom = _environment$getCompu.borderBottom,\n          paddingLeft = _environment$getCompu.paddingLeft,\n          paddingRight = _environment$getCompu.paddingRight,\n          paddingTop = _environment$getCompu.paddingTop,\n          paddingBottom = _environment$getCompu.paddingBottom;\n\n      var boxWidth = boxSizing === \"border-box\" ? getPixelValue(width) : sumOfPropertyValues(width, borderLeft, borderRight, paddingLeft, paddingRight);\n      var boxHeight = boxSizing === \"border-box\" ? getPixelValue(height) : sumOfPropertyValues(height, borderTop, borderBottom, paddingTop, paddingBottom);\n      bounds = new Bounds(_extends({}, bounds, {\n        width: boxWidth,\n        height: boxHeight\n      }));\n    }\n\n    if (!withScrollbars) {\n      var scrollbarWidth = bounds.width - element.clientWidth;\n      var scrollbarHeight = bounds.height - element.clientHeight;\n      return bounds.substract({\n        right: scrollbarWidth,\n        bottom: scrollbarHeight\n      });\n    }\n\n    return bounds;\n  }\n  /**\r\n   * Creates an empty Bounds class\r\n   */\n  ;\n\n  Bounds.empty = function empty() {\n    return new Bounds();\n  }\n  /**\r\n   * Creates a Bounds class from the window's dimensions\r\n   * @param environment reference to the window-object (needed when working with iframes for instance). Defaults to `window`\r\n   */\n  ;\n\n  Bounds.fromWindow = function fromWindow(environment) {\n    var _ref2 = environment || {},\n        _ref2$innerWidth = _ref2.innerWidth,\n        width = _ref2$innerWidth === void 0 ? 0 : _ref2$innerWidth,\n        _ref2$innerHeight = _ref2.innerHeight,\n        height = _ref2$innerHeight === void 0 ? 0 : _ref2$innerHeight;\n\n    return new Bounds({\n      width: width,\n      height: height,\n      right: width,\n      bottom: height\n    });\n  }\n  /**\r\n   * Returns the square surface of the bounds in pixels\r\n   */\n  ;\n\n  var _proto = Bounds.prototype;\n  /**\r\n   * Returns a plain object containing only positional properties\r\n   */\n\n  _proto.toObject = function toObject() {\n    return boundsToObject(this);\n  };\n\n  _proto.merge = function merge(partialBoundsOrMergeFn) {\n    var current = this.toObject();\n    return new Bounds(_extends({}, current, typeof partialBoundsOrMergeFn === \"function\" ? partialBoundsOrMergeFn(current) : partialBoundsOrMergeFn));\n  }\n  /**\r\n   * Return a new Bounds instance by subtracting each property of the provided IBounds object\r\n   * @param bounds partial IBounds object to substract with\r\n   */\n  ;\n\n  _proto.substract = function substract(bounds) {\n    var result = this.toObject();\n    var entries = Object.entries(bounds);\n\n    for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {\n      var _entries$_i = _entries[_i],\n          prop = _entries$_i[0],\n          value = _entries$_i[1];\n\n      if (prop in BoundSide) {\n        // if `prop` is one of 'top', 'left', 'bottom' or 'right'...\n        var boundSide = BoundSide[prop]; // decide if we should add or substract\n\n        result[prop] += boundSide.factor(value); // make sure that the size-properties are also updated\n\n        result[boundSide.isHorizontal ? \"width\" : \"height\"] -= value;\n      } else {\n        // prop is 'width' or 'height'\n        result[prop] -= value || 0;\n      }\n    }\n\n    return new Bounds(result);\n  }\n  /**\r\n   * Returns a new BoundsOffsets instance by determining the distance for each bound-side:\r\n   * (child -> parent)\r\n   * @param child child bounds instance\r\n   */\n  ;\n\n  _proto.offsetsTo = function offsetsTo(child) {\n    return new BoundsOffsets({\n      top: child.top - this.top,\n      bottom: this.bottom - child.bottom,\n      left: child.left - this.left,\n      right: this.right - child.right\n    });\n  }\n  /**\r\n   * Return a new Bounds instance by mapping over each bound-side\r\n   * @param mapper callback that takes a boundSide + value in pixels, returning a new value for that side\r\n   */\n  ;\n\n  _proto.mapSides = function mapSides(mapper) {\n    var result = this.toObject();\n    var boundSides = Object.values(BoundSide);\n\n    for (var _i2 = 0, _boundSides = boundSides; _i2 < _boundSides.length; _i2++) {\n      var boundSide = _boundSides[_i2];\n      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);\n    }\n\n    return new Bounds(result);\n  };\n\n  _createClass(Bounds, [{\n    key: \"surface\",\n    get: function get() {\n      return this.width * this.height;\n    }\n  }]);\n\n  return Bounds;\n}();\n/**\r\n * Class for various calculations based on a placement-type. I.e 'top-left';\r\n */\n\n\nvar Placement = /*#__PURE__*/function () {\n  function Placement(primary, secondary, subjectBounds, layerDimensions, offsets) {\n    this.primary = primary;\n    this.secondary = secondary;\n    this.offsets = offsets;\n    this._cachedLayerBounds = null;\n    this._cachedContainerOffsets = null;\n    this.setSubjectsBounds(subjectBounds, layerDimensions);\n  }\n  /**\r\n   * Set subjectsBounds that are specific for this placement\r\n   * @param subjectBounds original SubjectBounds instance\r\n   * @param layerDimensions possible config prodvided by the user\r\n   */\n\n\n  var _proto = Placement.prototype;\n\n  _proto.setSubjectsBounds = function setSubjectsBounds(subjectBounds, layerDimensions) {\n    // if user did not provide any layerDimensions config...\n    if (!layerDimensions) {\n      this.subjectsBounds = subjectBounds;\n      return;\n    } // get anticipated layer-dimensions provided by the user\n\n\n    var dimensions = // if the user passed a callback, call it with the layerSide corresponding to\n    // the placement\n    typeof layerDimensions === \"function\" ? layerDimensions(this.primary.prop) : layerDimensions; // create new SubjectsBounds instance by merging our newly create layer-bounds\n\n    this.subjectsBounds = subjectBounds.merge({\n      layer: _extends({}, subjectBounds.layer, dimensions)\n    });\n  }\n  /**\r\n   * Returns the string respresentation of this placement (ie. 'top-start')\r\n   */\n  ;\n  /**\r\n   * Calculates the actual boundaries based on the placement\r\n   * @param secondaryOffset optional offset on the secondary-side\r\n   */\n\n\n  _proto.getLayerBounds = function getLayerBounds(secondaryOffset) {\n    if (secondaryOffset === void 0) {\n      secondaryOffset = 0;\n    } // return cached version if possible\n\n\n    if (this._cachedLayerBounds && secondaryOffset === 0) {\n      return this._cachedLayerBounds;\n    }\n\n    var primary = this.primary,\n        secondary = this.secondary,\n        subjectsBounds = this.subjectsBounds;\n    var trigger = subjectsBounds.trigger,\n        layer = subjectsBounds.layer,\n        arrow = subjectsBounds.arrow;\n    var isHorizontal = primary.isHorizontal,\n        oppositeCssProp = primary.oppositeCssProp,\n        oppositeSizeProp = primary.oppositeSizeProp,\n        prop = primary.prop,\n        opposite = primary.opposite;\n    var result = Bounds.empty(); // let's take the placement 'top-start' as an example...\n    // the offsets are the following:\n    // trigger -> 8px\n    // container -> 10px;\n    // arrow -> 2px;\n    // PRIMARY STUFF\n    // bottom = trigger.top + 8;\n\n    result[opposite.prop] = trigger[prop] - primary.factor(this.offsets.trigger); // top = bottom - layer.height\n\n    result[prop] = result[opposite.prop] - primary.factor(layer[primary.sizeProp]); // SECONDARY STUFF\n    // arrowOffsetBase = 4\n\n    var arrowOffsetBase = this.offsets.arrow * 2; // limitMin = trigger.left - (layer.width - arrow.width) + 4\n\n    var limitMin = trigger[oppositeCssProp] - (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) + arrowOffsetBase; // limitMax = trigger.left + (trigger.width - arrow.width) - 4\n\n    var limitMax = trigger[oppositeCssProp] + (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) - arrowOffsetBase;\n\n    if (!secondary.isPush) {\n      // if secondary is bottom or right -> add the width or height of the layer\n      limitMin += layer[oppositeSizeProp];\n      limitMax += layer[oppositeSizeProp];\n    }\n\n    if (secondary.isCenter) {\n      var propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;\n      var propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right).prop; // left = limit(\n      //   trigger.left + trigger.width / 2 - layer.width / 2 + secondaryOffset,\n      //   limitMin,\n      //   limitMax\n      // )\n\n      result[propertyA] = limit(trigger[propertyA] + trigger[oppositeSizeProp] / 2 - layer[oppositeSizeProp] / 2 + secondaryOffset, limitMin, limitMax); // right = left + layer.width\n\n      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];\n    } else {\n      var sec = secondary;\n      var triggerValue = trigger[sec.prop]; // Under some conditions, when the layer is not able to align with the trigger\n      // due to arrow-size and arrow-offsets, we need to compensate.\n      // Otherwise, the secondary-offset will have no impact\n\n      var arrowCompensation = triggerValue < limitMin ? limitMin - triggerValue : triggerValue > limitMax ? limitMax - triggerValue : 0; // left = limit(\n      //   trigger.left + secondaryOffset + arrowCompensation,\n      //   limitMin,\n      //   limitMax\n      // )\n\n      result[sec.prop] = limit(triggerValue + secondaryOffset + arrowCompensation, limitMin, limitMax); // right = left + layer.width\n\n      result[sec.opposite.prop] = result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);\n    } // set the correct dimensions\n\n\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top; // create new bounds object\n\n    var layerBounds = Bounds.create(result);\n\n    if (secondaryOffset === 0) {\n      this._cachedLayerBounds = layerBounds;\n    }\n\n    return layerBounds;\n  }\n  /**\r\n   * Checks whether the trigger is bigger on the opposite side\r\n   * ie. placement \"top-start\" -> has trigger a bigger width?\r\n   */\n  ;\n  /**\r\n   * returns getLayerBounds(), including container-offsets\r\n   */\n\n\n  _proto.getLayerCollisionBounds = function getLayerCollisionBounds() {\n    var container = this.offsets.container;\n    return this.getLayerBounds().mapSides(function (side, value) {\n      return value -= side.factor(container);\n    }).merge(function (_ref) {\n      var width = _ref.width,\n          height = _ref.height;\n      return {\n        width: width + container * 2,\n        height: height + container * 2\n      };\n    });\n  }\n  /**\r\n   * Returns a BoundsOffsets instance containing merged offsets to containers with the most\r\n   * negative scenario\r\n   */\n  ;\n\n  _proto.getContainerOffsets = function getContainerOffsets(layerBounds) {\n    if (this._cachedContainerOffsets && !layerBounds) {\n      return this._cachedContainerOffsets;\n    }\n\n    var subjectBounds = this.subjectsBounds.merge({\n      layer: layerBounds || this.getLayerCollisionBounds()\n    });\n    var offsets = BoundsOffsets.mergeSmallestSides(subjectBounds.layerOffsetsToScrollContainers);\n\n    if (!layerBounds) {\n      this._cachedContainerOffsets = offsets;\n    }\n\n    return offsets;\n  };\n\n  _createClass(Placement, [{\n    key: \"type\",\n    get: function get() {\n      return this.primary.prop + \"-\" + (this.secondary.prop === \"center\" ? \"center\" : [\"bottom\", \"right\"].includes(this.secondary.prop) ? \"end\" : \"start\");\n    }\n  }, {\n    key: \"triggerIsBigger\",\n    get: function get() {\n      var isHorizontal = this.secondary.isHorizontal;\n      var _this$subjectsBounds = this.subjectsBounds,\n          triggerHasBiggerWidth = _this$subjectsBounds.triggerHasBiggerWidth,\n          triggerHasBiggerHeight = _this$subjectsBounds.triggerHasBiggerHeight;\n      return isHorizontal && triggerHasBiggerWidth || !isHorizontal && triggerHasBiggerHeight;\n    }\n    /**\r\n     * Checks whether the placement fits within all it's container (including container-offset)\r\n     */\n\n  }, {\n    key: \"fitsContainer\",\n    get: function get() {\n      return this.getContainerOffsets().allSidesArePositive;\n    }\n    /**\r\n     * Returns the surface in square pixels of the visible part of the layer\r\n     */\n\n  }, {\n    key: \"visibleSurface\",\n    get: function get() {\n      var layerBounds = this.getLayerBounds();\n      var containerOffsets = this.getContainerOffsets(layerBounds);\n      var substract = containerOffsets.negativeSides;\n\n      for (var side in substract) {\n        // @ts-ignore\n        substract[side] = -substract[side]; // make positive for substraction;\n      }\n\n      return layerBounds.substract(substract).surface;\n    }\n    /**\r\n     * Returns a BoundSide by looking at the most negative offset that is the opposite direction\r\n     */\n\n  }, {\n    key: \"secondaryOffsetSide\",\n    get: function get() {\n      var _Object$entries$map$f,\n          _Object$entries$map$f2,\n          _this = this; // Given placement 'top-start' and containerOffsets { left: -20, top: -10, right: -10, bottom: 200 }...\n      // the only negative offsets on the opposite side are { left: -20, right: -10 }\n      // since we have to return only 1 side, we pick the most negative, which is 'left'\n\n\n      var containerOffsets = this.getContainerOffsets();\n\n      var _ref2 = (_Object$entries$map$f = (_Object$entries$map$f2 = Object.entries(containerOffsets.negativeSides).map(function (_ref3) {\n        var side = _ref3[0],\n            value = _ref3[1];\n        return [BoundSide[side], value];\n      }).filter(function (_ref4) {\n        var side = _ref4[0];\n        return _this.primary.isOppositeDirection(side);\n      }).sort(function (_ref5, _ref6) {\n        var a = _ref5[1];\n        var b = _ref6[1];\n        return b - a;\n      })) == null ? void 0 : _Object$entries$map$f2[0]) != null ? _Object$entries$map$f : [],\n          mostNegativeSide = _ref2[0];\n\n      return mostNegativeSide || null;\n    }\n  }]);\n\n  return Placement;\n}();\n\nvar PlacementCenter = /*#__PURE__*/function (_Placement) {\n  _inheritsLoose(PlacementCenter, _Placement);\n\n  function PlacementCenter() {\n    return _Placement.apply(this, arguments) || this;\n  }\n\n  var _proto2 = PlacementCenter.prototype;\n\n  _proto2.getLayerBounds = function getLayerBounds() {\n    var _this$subjectsBounds2 = this.subjectsBounds,\n        trigger = _this$subjectsBounds2.trigger,\n        layer = _this$subjectsBounds2.layer;\n    var result = Bounds.empty();\n    result.top = trigger.top + trigger.height / 2 - layer.height / 2;\n    result.bottom = result.top + layer.height;\n    result.left = trigger.left + trigger.width / 2 - layer.width / 2;\n    result.right = result.left + layer.width;\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n    return result;\n  };\n\n  return PlacementCenter;\n}(Placement);\n\nfunction getNegativeOffsetBetweenLayerCenterAndTrigger(subjectsBounds, placement, arrowOffset) {\n  var layer = subjectsBounds.layer,\n      trigger = subjectsBounds.trigger,\n      arrow = subjectsBounds.arrow;\n  var sizeProperty = placement.primary.oppositeSizeProp;\n\n  var _ref = !placement.primary.isHorizontal ? [\"left\", \"right\"] : [\"top\", \"bottom\"],\n      sideA = _ref[0],\n      sideB = _ref[1];\n\n  var offsetA = layer[sideA] + layer[sizeProperty] / 2 - trigger[sideA] - arrow[sizeProperty] / 2 - arrowOffset;\n  var offsetB = layer[sideB] - layer[sizeProperty] / 2 - trigger[sideB] + arrow[sizeProperty] / 2 + arrowOffset;\n  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);\n}\n\nvar STYLE_BASE = {\n  position: \"absolute\",\n  willChange: \"top, left\",\n  left: null,\n  right: null,\n  top: null,\n  bottom: null\n};\n\nfunction getArrowStyle(subjectsBounds, placement, arrowOffset) {\n  var _extends2;\n\n  if (placement.primary.isCenter) {\n    return STYLE_BASE;\n  }\n\n  var layer = subjectsBounds.layer,\n      trigger = subjectsBounds.trigger,\n      arrow = subjectsBounds.arrow;\n  var sizeProperty = placement.primary.oppositeSizeProp;\n  var triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];\n  var min = arrowOffset + arrow[sizeProperty] / 2;\n  var max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;\n  var negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(subjectsBounds, placement, arrowOffset);\n  var primarySide = placement.primary.prop;\n  var secondarySide = placement.primary.oppositeCssProp;\n  var secondaryValue = triggerIsBigger ? layer[sizeProperty] / 2 + negativeOffset : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];\n  return _extends({}, STYLE_BASE, (_extends2 = {}, _extends2[primarySide] = \"100%\", _extends2[secondarySide] = limit(secondaryValue, min, max), _extends2));\n}\n/**\r\n * Class mostly concerned about calculating and finding the right placement\r\n */\n\n\nvar Placements = /*#__PURE__*/function () {\n  function Placements(placements, config, subjectsBounds) {\n    this.placements = placements;\n    this.config = config;\n    this.subjectsBounds = subjectsBounds;\n  }\n  /**\r\n   * Converts a placement-type into a primary-side and a secondary-side\r\n   */\n\n\n  Placements.getSidesFromPlacementType = function getSidesFromPlacementType(type) {\n    var _type$split = type.split(\"-\"),\n        a = _type$split[0],\n        b = _type$split[1];\n\n    var primary = BoundSide[a];\n    var secondary;\n\n    if (b === \"center\") {\n      secondary = Side.center;\n    } else if (primary.isHorizontal) {\n      secondary = b === \"start\" ? Side.top : Side.bottom;\n    } else {\n      secondary = b === \"start\" ? Side.left : Side.right;\n    }\n\n    return [primary, secondary];\n  }\n  /**\r\n   * Main static method to create a Placements instance\r\n   * @param subjectsBounds instance of the SubjectsBounds class\r\n   * @param config config provided by the user\r\n   */\n  ;\n\n  Placements.create = function create(subjectsBounds, config) {\n    // create offsets-object from user config\n    var offsets = {\n      arrow: config.arrowOffset,\n      container: config.containerOffset,\n      trigger: config.triggerOffset\n    }; // function which creates a prioritized list of possible placments\n    // by looking at user-config\n\n    function getListOfPlacements(preferedPlacement) {\n      if (preferedPlacement === void 0) {\n        preferedPlacement = config.placement;\n      }\n\n      var _Placements$getSidesF = Placements.getSidesFromPlacementType(preferedPlacement),\n          primary = _Placements$getSidesF[0],\n          secondary = _Placements$getSidesF[1];\n\n      var preferredSide = BoundSide[primary.isHorizontal ? config.preferY : config.preferX]; // some priorities may alter when the trigger is bigger\n\n      var triggerIsBigger = !primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth || primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight; // utility function which constructs a placement by primary and secondary sides\n\n      function placementFrom(primary, secondary) {\n        return new Placement(primary, secondary, subjectsBounds, config.layerDimensions, offsets);\n      } // creating the list\n\n\n      var list = [];\n      list[0] = placementFrom(primary, secondary);\n      list[1] = placementFrom(primary, secondary.isCenter ? preferredSide : Side.center);\n      list[2] = placementFrom(primary, Side[(secondary.opposite.isCenter ? preferredSide.opposite : secondary.opposite).prop]);\n      list[3] = placementFrom(preferredSide, triggerIsBigger ? primary : Side[primary.opposite.prop]);\n      list[4] = placementFrom(preferredSide, Side.center);\n      list[5] = placementFrom(preferredSide, triggerIsBigger ? Side[primary.opposite.prop] : primary);\n      list[6] = placementFrom(BoundSide[preferredSide.opposite.prop], triggerIsBigger ? primary : Side[primary.opposite.prop]);\n      list[7] = placementFrom(BoundSide[preferredSide.opposite.prop], Side.center);\n      list[8] = placementFrom(BoundSide[preferredSide.opposite.prop], triggerIsBigger ? Side[primary.opposite.prop] : primary);\n      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);\n      list[10] = placementFrom(BoundSide[primary.opposite.prop], secondary.isCenter ? preferredSide : Side.center);\n      list[11] = placementFrom(BoundSide[primary.opposite.prop], Side[(secondary.opposite.isCenter ? preferredSide.opposite : secondary.opposite).prop]); // only include placements that are part of 'possible-placements'\n\n      list = list.filter(function (placement) {\n        return placement.type === config.placement || config.possiblePlacements.includes(placement.type);\n      });\n      return list;\n    } // treat placement 'center' a little bit different\n\n\n    if (config.placement === \"center\") {\n      return new Placements([new PlacementCenter(Side.center, Side.center, subjectsBounds, config.layerDimensions, offsets)].concat(getListOfPlacements(config.preferY + \"-\" + config.preferX)), config, subjectsBounds);\n    }\n\n    return new Placements(getListOfPlacements(), config, subjectsBounds);\n  };\n\n  var _proto = Placements.prototype;\n\n  _proto.filterPlacementsBySide = function filterPlacementsBySide(side) {\n    return this.placements.filter(function (placement) {\n      return placement.primary === side;\n    });\n  };\n\n  _proto.findFirstPlacementThatFits = function findFirstPlacementThatFits() {\n    return this.placements.find(function (placement) {\n      return placement.fitsContainer;\n    });\n  };\n\n  _proto.placementWithBiggestVisibleSurface = function placementWithBiggestVisibleSurface() {\n    var _this$placements$map$ = this.placements.map(function (placement) {\n      return {\n        placement: placement,\n        surface: placement.visibleSurface\n      };\n    }) // sort -> biggest surface first\n    .sort(function (a, b) {\n      return b.surface - a.surface;\n    }),\n        placementWithBiggestSurface = _this$placements$map$[0].placement;\n\n    return placementWithBiggestSurface;\n  };\n\n  _proto.findSuitablePlacement = function findSuitablePlacement() {\n    if (!this.config.auto) {\n      return this.placements[0];\n    }\n\n    return this.findFirstPlacementThatFits() || this.placementWithBiggestVisibleSurface();\n  }\n  /**\r\n   * secondary offset: the number of pixels between the edge of the\r\n   * scroll-container and the current placement, on the side of the layer\r\n   * that didn't fit.\r\n   * Eventually this secondary offset gets added / subtracted from the\r\n   * placement that does fit in order to move the layer closer to the\r\n   * position of the placement that just would not fit.\r\n   * This creates the effect that the layer is moving gradually from one\r\n   * placement to the next as the users scrolls the page or scroll-container\r\n   */\n  ;\n\n  _proto.getSecondaryOffset = function getSecondaryOffset(placement) {\n    var _this$config = this.config,\n        auto = _this$config.auto,\n        snap = _this$config.snap; // return early when we're not interested...\n\n    if (!auto || snap || placement instanceof PlacementCenter) {\n      return 0;\n    } // if current placement fits and is prefered placement...\n    // return early\n\n\n    var placementsOnSameSide = this.filterPlacementsBySide(placement.primary);\n    var currentPlacementHasHighestPriority = placementsOnSameSide.indexOf(placement) === 0;\n\n    if (currentPlacementHasHighestPriority && placement.fitsContainer) {\n      return 0;\n    }\n\n    var firstPlacementThatDoesNotFit = placementsOnSameSide.find(function (placement) {\n      return !placement.fitsContainer;\n    });\n\n    if (!firstPlacementThatDoesNotFit) {\n      return 0;\n    }\n\n    var secondaryOffsetSide = firstPlacementThatDoesNotFit.secondaryOffsetSide;\n\n    if (!secondaryOffsetSide) {\n      return 0;\n    }\n\n    var containerOffsets = placement.getContainerOffsets(); // determine whether we should add or substract the secondary-offset\n\n    var secondary = placement.secondary;\n    var factor;\n\n    if (placement.triggerIsBigger || firstPlacementThatDoesNotFit === placement) {\n      factor = secondaryOffsetSide.isPush ? -1 : 1;\n    } else {\n      factor = secondary === Side.left || [Side.top, Side.center].includes(secondary) && secondaryOffsetSide.isPush ? -1 : 1;\n    } // get number of pixels between placement that did not fit and current\n    // placement\n\n\n    var secondaryOffset = containerOffsets[secondaryOffsetSide.prop];\n    return secondaryOffset * factor;\n  };\n\n  _proto.getStyles = function getStyles(layerBounds, placement, scrollOffsets, borderOffsets) {\n    var layerStyleBase = {\n      willChange: \"top, left, width, height\"\n    };\n    var arrow = getArrowStyle(this.subjectsBounds.merge({\n      layer: layerBounds\n    }), placement, this.config.arrowOffset);\n    var layer = this.config.overflowContainer ? _extends({}, layerStyleBase, {\n      position: \"fixed\",\n      top: layerBounds.top,\n      left: layerBounds.left\n    }) : _extends({}, layerStyleBase, {\n      position: \"absolute\",\n      top: layerBounds.top - this.subjectsBounds.parent.top + scrollOffsets.top - borderOffsets.top,\n      left: layerBounds.left - this.subjectsBounds.parent.left + scrollOffsets.left - borderOffsets.left\n    });\n    return {\n      arrow: arrow,\n      layer: layer\n    };\n  };\n\n  _proto.getHasDisappeared = function getHasDisappeared(layerBounds) {\n    var subject = this.config.overflowContainer ? this.subjectsBounds.trigger : layerBounds;\n    var containerOffsets = BoundsOffsets.mergeSmallestSides(this.subjectsBounds.offsetsToScrollContainers(subject, true));\n    var entries = Object.entries(containerOffsets.negativeSides);\n    var hasFullyDisappeared = entries.some(function (_ref) {\n      var prop = _ref[0],\n          value = _ref[1];\n      var side = BoundSide[prop];\n      return value <= -subject[side.sizeProp];\n    });\n\n    if (hasFullyDisappeared) {\n      return \"full\";\n    }\n\n    if (!containerOffsets.allSidesArePositive) {\n      return \"partial\";\n    }\n\n    return null;\n  };\n\n  _proto.result = function result(scrollOffsets, borderOffsets) {\n    var suitablePlacement = this.findSuitablePlacement();\n    var secondaryOffset = this.getSecondaryOffset(suitablePlacement);\n    var layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);\n    var styles = this.getStyles(layerBounds, suitablePlacement, scrollOffsets, borderOffsets);\n    var layerSide = suitablePlacement.primary.prop;\n    return {\n      styles: styles,\n      layerSide: layerSide,\n      placement: suitablePlacement,\n      layerBounds: layerBounds,\n      hasDisappeared: this.getHasDisappeared(layerBounds)\n    };\n  };\n\n  return Placements;\n}();\n\nvar SubjectsBounds = /*#__PURE__*/function () {\n  function SubjectsBounds(subjectsBounds, overflowContainer) {\n    this.overflowContainer = overflowContainer;\n    Object.assign(this, subjectsBounds);\n  }\n\n  SubjectsBounds.create = function create(environment, layer, trigger, parent, arrow, scrollContainers, overflowContainer, getTriggerBounds) {\n    var window = Bounds.fromWindow(environment);\n    return new SubjectsBounds({\n      layer: Bounds.fromElement(layer, {\n        environment: environment,\n        withTransform: false\n      }),\n      trigger: getTriggerBounds ? Bounds.create(boundsToObject(getTriggerBounds())) : Bounds.fromElement(trigger),\n      arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),\n      parent: parent ? Bounds.fromElement(parent) : window,\n      window: window,\n      scrollContainers: [window].concat(scrollContainers.map(function (container) {\n        return Bounds.fromElement(container, {\n          withScrollbars: false\n        });\n      }))\n    }, overflowContainer);\n  };\n\n  var _proto = SubjectsBounds.prototype;\n\n  _proto.merge = function merge(subjectsBounds) {\n    return new SubjectsBounds(_extends({}, this, subjectsBounds), this.overflowContainer);\n  };\n\n  _proto.offsetsToScrollContainers = function offsetsToScrollContainers(subject, allContainers) {\n    if (allContainers === void 0) {\n      allContainers = false;\n    }\n\n    var scrollContainers = this.overflowContainer && !allContainers ? [this.window] : this.scrollContainers;\n    return scrollContainers.map(function (scrollContainer) {\n      return scrollContainer.offsetsTo(subject);\n    });\n  };\n\n  _createClass(SubjectsBounds, [{\n    key: \"layerOffsetsToScrollContainers\",\n    get: function get() {\n      return this.offsetsToScrollContainers(this.layer);\n    }\n  }, {\n    key: \"triggerHasBiggerWidth\",\n    get: function get() {\n      return this.trigger.width > this.layer.width;\n    }\n  }, {\n    key: \"triggerHasBiggerHeight\",\n    get: function get() {\n      return this.trigger.height > this.layer.height;\n    }\n  }]);\n\n  return SubjectsBounds;\n}();\n\nvar GLOBAL_CONTAINER = null;\n\nfunction setGlobalContainer(container) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(!(GLOBAL_CONTAINER instanceof HTMLElement), \"react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.\") : void 0;\n\n  if (typeof container === \"function\") {\n    GLOBAL_CONTAINER = container();\n  } else if (typeof container === \"string\") {\n    GLOBAL_CONTAINER = document.getElementById(container);\n  } else {\n    GLOBAL_CONTAINER = container;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(GLOBAL_CONTAINER instanceof HTMLElement, \"react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element\") : void 0;\n}\n\nvar DEFAULT_OPTIONS = {\n  auto: false,\n  arrowOffset: 0,\n  containerOffset: 10,\n  triggerOffset: 0,\n  overflowContainer: true,\n  placement: \"top-center\",\n  possiblePlacements: PLACEMENT_TYPES,\n  preferX: \"right\",\n  preferY: \"bottom\",\n  snap: false,\n  container: undefined,\n  trigger: undefined\n};\n\nfunction useLayer(_ref) {\n  var _triggerBoundsRef$cur;\n\n  var _ref$isOpen = _ref.isOpen,\n      isOpen = _ref$isOpen === void 0 ? false : _ref$isOpen,\n      _ref$overflowContaine = _ref.overflowContainer,\n      overflowContainer = _ref$overflowContaine === void 0 ? DEFAULT_OPTIONS.overflowContainer : _ref$overflowContaine,\n      _ref$environment = _ref.environment,\n      environment = _ref$environment === void 0 ? typeof window !== \"undefined\" ? window : undefined : _ref$environment,\n      ResizeObserverPolyfill = _ref.ResizeObserver,\n      _ref$placement = _ref.placement,\n      placement = _ref$placement === void 0 ? DEFAULT_OPTIONS.placement : _ref$placement,\n      _ref$possiblePlacemen = _ref.possiblePlacements,\n      possiblePlacements = _ref$possiblePlacemen === void 0 ? DEFAULT_OPTIONS.possiblePlacements : _ref$possiblePlacemen,\n      _ref$preferX = _ref.preferX,\n      preferX = _ref$preferX === void 0 ? DEFAULT_OPTIONS.preferX : _ref$preferX,\n      _ref$preferY = _ref.preferY,\n      preferY = _ref$preferY === void 0 ? DEFAULT_OPTIONS.preferY : _ref$preferY,\n      _ref$auto = _ref.auto,\n      auto = _ref$auto === void 0 ? DEFAULT_OPTIONS.auto : _ref$auto,\n      _ref$snap = _ref.snap,\n      snap = _ref$snap === void 0 ? DEFAULT_OPTIONS.snap : _ref$snap,\n      _ref$triggerOffset = _ref.triggerOffset,\n      triggerOffset = _ref$triggerOffset === void 0 ? DEFAULT_OPTIONS.triggerOffset : _ref$triggerOffset,\n      _ref$containerOffset = _ref.containerOffset,\n      containerOffset = _ref$containerOffset === void 0 ? DEFAULT_OPTIONS.containerOffset : _ref$containerOffset,\n      _ref$arrowOffset = _ref.arrowOffset,\n      arrowOffset = _ref$arrowOffset === void 0 ? DEFAULT_OPTIONS.arrowOffset : _ref$arrowOffset,\n      _ref$container = _ref.container,\n      container = _ref$container === void 0 ? DEFAULT_OPTIONS.container : _ref$container,\n      _ref$layerDimensions = _ref.layerDimensions,\n      layerDimensions = _ref$layerDimensions === void 0 ? null : _ref$layerDimensions,\n      onDisappear = _ref.onDisappear,\n      onOutsideClick = _ref.onOutsideClick,\n      onParentClose = _ref.onParentClose,\n      triggerOption = _ref.trigger; // initialize styles\n\n  var _useState = useState(function () {\n    return {\n      layerSide: placement === \"center\" ? \"center\" : Placements.getSidesFromPlacementType(placement)[0].prop,\n      styles: {\n        layer: {\n          position: overflowContainer ? \"fixed\" : \"absolute\",\n          top: 0,\n          left: 0\n        },\n        arrow: {\n          position: \"absolute\",\n          top: 0,\n          left: 0\n        }\n      }\n    };\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var triggerBoundsRef = useRef(null); // tracks state in order for us to use read inside functions that require dependencies,\n  // like `useCallback`, without triggering an update\n\n  var lastState = useLastState(state, isOpen); // keeps track of scheduled animation-frames\n\n  var raf = useRef(null);\n  useEffect(function () {\n    return function () {\n      // when this hook unmounts, make sure to cancel any scheduled animation-frames\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = null;\n      }\n    };\n  }, []); // Most important function regarding positioning\n  // It receives boundaries collected by `useTrackElements`, does some calculations,\n  // sets new styles, and handles when a layer has disappeared.\n\n  var handlePositioning = useCallback(function handlePositioning(_ref2, scrollOffsets, borderOffsets) {\n    var arrow = _ref2.arrow,\n        layer = _ref2.layer,\n        scrollContainers = _ref2.scrollContainers,\n        trigger = _ref2.trigger;\n    var parent = scrollContainers[0];\n    var subjectsBounds = SubjectsBounds.create(environment, layer, trigger, parent, arrow, scrollContainers, overflowContainer, triggerOption == null ? void 0 : triggerOption.getBounds);\n    var config = {\n      placement: placement,\n      possiblePlacements: possiblePlacements,\n      auto: auto,\n      layerDimensions: layerDimensions,\n      arrowOffset: arrowOffset,\n      containerOffset: containerOffset,\n      triggerOffset: triggerOffset,\n      preferX: preferX,\n      preferY: preferY,\n      snap: snap,\n      overflowContainer: overflowContainer\n    };\n\n    var _Placements$create$re = Placements.create(subjectsBounds, config).result(scrollOffsets, borderOffsets),\n        hasDisappeared = _Placements$create$re.hasDisappeared,\n        layerSide = _Placements$create$re.layerSide,\n        styles = _Placements$create$re.styles;\n\n    var newState = {\n      layerSide: layerSide,\n      styles: styles\n    };\n\n    if (!lastState.current || didStateChange(lastState.current, newState)) {\n      lastState.current = newState; // optimistically update lastState to prevent infinite loop\n\n      /**\r\n       * We're using requestAnimationFrame-features here to ensure that position updates will\r\n       * happen max once per frame.\r\n       * If during a frame there's already an update scheduled, the existing update will be cancelled\r\n       * and the new update will take precedence.\r\n       */\n\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n\n      raf.current = requestAnimationFrame(function () {\n        setState(newState);\n        raf.current = null;\n      });\n    }\n\n    if (isSet(hasDisappeared) && isSet(onDisappear)) {\n      onDisappear(hasDisappeared);\n    }\n  }, [arrowOffset, auto, containerOffset, environment, layerDimensions, onDisappear, overflowContainer, placement, possiblePlacements, preferX, preferY, snap, triggerOffset, lastState, triggerOption]);\n\n  var _useTrackElements = useTrackElements({\n    ResizeObserverPolyfill: ResizeObserverPolyfill,\n    environment: environment,\n    enabled: isOpen,\n    overflowContainer: overflowContainer,\n    onChange: handlePositioning,\n    triggerOption: triggerOption\n  }),\n      triggerRef = _useTrackElements.triggerRef,\n      layerRef = _useTrackElements.layerRef,\n      arrowRef = _useTrackElements.arrowRef,\n      closestScrollContainer = _useTrackElements.closestScrollContainer;\n\n  var _useGroup = useGroup({\n    isOpen: isOpen,\n    onOutsideClick: onOutsideClick,\n    onParentClose: onParentClose\n  }),\n      closeOnOutsideClickRefs = _useGroup.closeOnOutsideClickRefs,\n      registrations = _useGroup.registrations;\n\n  var props = {\n    triggerProps: Boolean(triggerOption) ? {} // when using the `trigger` option, make `triggerProps` useless\n    : {\n      ref: mergeRefs(triggerRef, closeOnOutsideClickRefs.trigger, triggerBoundsRef)\n    },\n    layerProps: {\n      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),\n      style: state.styles.layer\n    },\n    arrowProps: {\n      ref: arrowRef,\n      style: state.styles.arrow,\n      layerSide: state.layerSide\n    },\n    layerSide: state.layerSide,\n    triggerBounds: isOpen ? triggerOption ? triggerOption.getBounds() : (_triggerBoundsRef$cur = triggerBoundsRef.current) == null ? void 0 : _triggerBoundsRef$cur.getBoundingClientRect() : null,\n    renderLayer: function renderLayer(children) {\n      return typeof document !== \"undefined\" ? createPortal(createElement(GroupProvider, {\n        registrations: registrations,\n        children: children\n      }), overflowContainer || !closestScrollContainer ? getContainerElement(container) : closestScrollContainer) : null;\n    }\n  };\n  return props;\n}\n\nfunction didStateChange(previous, next) {\n  if (previous.layerSide !== next.layerSide) {\n    return true;\n  }\n\n  var styleProps = [\"position\", \"top\", \"left\", \"right\", \"bottom\"];\n\n  for (var _i = 0, _styleProps = styleProps; _i < _styleProps.length; _i++) {\n    var prop = _styleProps[_i];\n\n    if (previous.styles.layer[prop] !== next.styles.layer[prop] || previous.styles.arrow[prop] !== next.styles.arrow[prop]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar DEFAULT_CONTAINER_ID = \"layers\";\n\nfunction getContainerElement(container) {\n  var element;\n\n  if (typeof container === \"function\") {\n    element = container();\n\n    if (!element || !(element instanceof HTMLElement)) {\n      throw new Error(\"react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement\");\n    }\n  } else if (container instanceof HTMLElement) {\n    element = container;\n  } else if (typeof container === \"string\") {\n    element = document.getElementById(container);\n\n    if (!element) {\n      throw new Error(\"react-laag: You've passed element with id '\" + container + \"' to the 'container' prop, but it returned no valid HTMLElement\");\n    }\n  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {\n    return GLOBAL_CONTAINER;\n  } else {\n    element = document.getElementById(DEFAULT_CONTAINER_ID);\n\n    if (!element) {\n      element = document.createElement(\"div\");\n      element.id = DEFAULT_CONTAINER_ID;\n      element.style.cssText = \"\\n        position: absolute;\\n        top: 0px;\\n        left: 0px;\\n        right: 0px;\\n      \";\n      document.body.appendChild(element);\n    }\n  }\n\n  return element;\n}\n\nvar LEFT = \"left\";\nvar TOP = \"top\";\nvar BOTTOM = \"bottom\";\nvar RIGHT = \"right\";\n\nfunction getWidthBasedOnAngle(angle, size) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(sizeA, sizeB, side, borderWidth) {\n  var _map;\n\n  var map = (_map = {}, _map[BOTTOM] = \"0 \" + -borderWidth + \" \" + sizeB + \" \" + sizeA, _map[TOP] = \"0 0 \" + sizeB + \" \" + (sizeA + borderWidth), _map[RIGHT] = -borderWidth + \" 0 \" + sizeA + \" \" + sizeB, _map[LEFT] = \"0 0 \" + (sizeA + borderWidth) + \" \" + sizeB, _map);\n  return map[side.prop];\n}\n\nfunction getTrianglePath(sizeA, sizeB, side, roundness, angle) {\n  var _BOTTOM$TOP$RIGHT$LEF, _BOTTOM$TOP$RIGHT$LEF2, _BOTTOM$TOP$RIGHT$LEF3;\n\n  var relativeRoundness = roundness / 10 * sizeA * 2;\n  var A = (_BOTTOM$TOP$RIGHT$LEF = {}, _BOTTOM$TOP$RIGHT$LEF[BOTTOM] = [0, sizeA], _BOTTOM$TOP$RIGHT$LEF[TOP] = [0, 0], _BOTTOM$TOP$RIGHT$LEF[RIGHT] = [sizeA, sizeB], _BOTTOM$TOP$RIGHT$LEF[LEFT] = [0, sizeB], _BOTTOM$TOP$RIGHT$LEF)[side.prop].join(\" \");\n  var B = side.isHorizontal ? \"V 0\" : \"H \" + sizeB;\n  var cPoint = sizeB / 2;\n  var c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  var c1B = sizeA / 8;\n  var C = (_BOTTOM$TOP$RIGHT$LEF2 = {}, _BOTTOM$TOP$RIGHT$LEF2[BOTTOM] = [\"C\", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0], _BOTTOM$TOP$RIGHT$LEF2[TOP] = [\"C\", c1A, sizeA - c1B, cPoint + relativeRoundness, sizeA, cPoint, sizeA], _BOTTOM$TOP$RIGHT$LEF2[RIGHT] = [\"C\", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint], _BOTTOM$TOP$RIGHT$LEF2[LEFT] = [\"C\", sizeA - c1B, sizeB - c1A, sizeA, cPoint - relativeRoundness, sizeA, cPoint], _BOTTOM$TOP$RIGHT$LEF2)[side.prop].join(\" \");\n  var d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  var d1B = sizeA / 8;\n  var D = (_BOTTOM$TOP$RIGHT$LEF3 = {}, _BOTTOM$TOP$RIGHT$LEF3[BOTTOM] = [\"C\", cPoint - relativeRoundness, 0, d1A, d1B, A], _BOTTOM$TOP$RIGHT$LEF3[TOP] = [\"C\", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A], _BOTTOM$TOP$RIGHT$LEF3[RIGHT] = [\"C\", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A], _BOTTOM$TOP$RIGHT$LEF3[LEFT] = [\"C\", sizeA, cPoint + relativeRoundness, sizeA - d1B, sizeB - d1A, A], _BOTTOM$TOP$RIGHT$LEF3)[side.prop].join(\" \");\n  return [\"M\", A, B, C, D].join(\" \");\n}\n\nfunction getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle) {\n  var borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  var _ref = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth],\n      A = _ref[0],\n      B = _ref[1];\n\n  if (side.isHorizontal) {\n    return [\"M\", A, borderWidth, \"V\", sizeB - borderWidth, \"L\", B, sizeB - borderWidth - borderOffset, \"V\", borderOffset + borderWidth, \"Z\"].join(\" \");\n  }\n\n  return [\"M\", borderWidth, A, \"H\", sizeB - borderWidth, \"L\", sizeB - borderWidth - borderOffset, B, \"H\", borderOffset + borderWidth, \"Z\"].join(\" \");\n}\n\nvar Arrow = /*#__PURE__*/forwardRef(function Arrow(_ref2, ref) {\n  var _ref2$size = _ref2.size,\n      size = _ref2$size === void 0 ? 8 : _ref2$size,\n      _ref2$angle = _ref2.angle,\n      angle = _ref2$angle === void 0 ? 45 : _ref2$angle,\n      _ref2$borderWidth = _ref2.borderWidth,\n      borderWidth = _ref2$borderWidth === void 0 ? 0 : _ref2$borderWidth,\n      _ref2$borderColor = _ref2.borderColor,\n      borderColor = _ref2$borderColor === void 0 ? \"black\" : _ref2$borderColor,\n      _ref2$roundness = _ref2.roundness,\n      roundness = _ref2$roundness === void 0 ? 0 : _ref2$roundness,\n      _ref2$backgroundColor = _ref2.backgroundColor,\n      backgroundColor = _ref2$backgroundColor === void 0 ? \"white\" : _ref2$backgroundColor,\n      _ref2$layerSide = _ref2.layerSide,\n      layerSide = _ref2$layerSide === void 0 ? \"top\" : _ref2$layerSide,\n      _ref2$style = _ref2.style,\n      style = _ref2$style === void 0 ? {} : _ref2$style,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"size\", \"angle\", \"borderWidth\", \"borderColor\", \"roundness\", \"backgroundColor\", \"layerSide\", \"style\"]);\n\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  var side = BoundSide[layerSide];\n  var sizeA = size;\n  var sizeB = getWidthBasedOnAngle(angle, size) * 2;\n  var maxSize = Math.max(sizeA, sizeB);\n  return createElement(\"svg\", _extends({\n    ref: ref\n  }, rest, {\n    style: _extends({}, style, {\n      transform: \"translate\" + (side.isHorizontal ? \"Y\" : \"X\") + \"(-50%)\"\n    }),\n    width: maxSize,\n    height: maxSize,\n    preserveAspectRatio: side.isPush ? \"xMinYMin\" : \"xMaxYMax\",\n    viewBox: getViewBox(sizeA, sizeB, side, borderWidth)\n  }), createElement(\"path\", {\n    fill: backgroundColor,\n    strokeWidth: borderWidth,\n    stroke: borderColor,\n    d: getTrianglePath(sizeA, sizeB, side, roundness, angle)\n  }), createElement(\"path\", {\n    fill: backgroundColor,\n    d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)\n  }));\n});\nvar Status;\n\n(function (Status) {\n  Status[Status[\"ENTERING\"] = 0] = \"ENTERING\";\n  Status[Status[\"LEAVING\"] = 1] = \"LEAVING\";\n  Status[Status[\"IDLE\"] = 2] = \"IDLE\";\n})(Status || (Status = {}));\n\nfunction useHover(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$delayEnter = _ref.delayEnter,\n      delayEnter = _ref$delayEnter === void 0 ? 0 : _ref$delayEnter,\n      _ref$delayLeave = _ref.delayLeave,\n      delayLeave = _ref$delayLeave === void 0 ? 0 : _ref$delayLeave,\n      _ref$hideOnScroll = _ref.hideOnScroll,\n      hideOnScroll = _ref$hideOnScroll === void 0 ? true : _ref$hideOnScroll;\n\n  var _useState = useState(false),\n      show = _useState[0],\n      setShow = _useState[1];\n\n  var timeout = useRef(null);\n  var status = useRef(Status.IDLE);\n  var hasTouchMoved = useRef(false);\n  var removeTimeout = useCallback(function removeTimeout() {\n    clearTimeout(timeout.current);\n    timeout.current = null;\n    status.current = Status.IDLE;\n  }, []);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (status.current === Status.LEAVING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (show) {\n      return;\n    }\n\n    status.current = Status.ENTERING;\n    timeout.current = setTimeout(function () {\n      setShow(true);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayEnter);\n  }\n\n  function onMouseLeave(_, immediate) {\n    // if was waiting for entering,\n    // clear timeout\n    if (status.current === Status.ENTERING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (!show) {\n      return;\n    }\n\n    if (immediate) {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n      return;\n    }\n\n    status.current = Status.LEAVING;\n    timeout.current = setTimeout(function () {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayLeave);\n  } // make sure to clear timeout on unmount\n\n\n  useEffect(function () {\n    var currentTimeout = timeout.current;\n\n    function onScroll() {\n      if (show && hideOnScroll) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    function onTouchEnd() {\n      if (show) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n    window.addEventListener(\"touchend\", onTouchEnd, true);\n    return function () {\n      window.removeEventListener(\"scroll\", onScroll, true);\n      window.removeEventListener(\"touchend\", onTouchEnd, true);\n\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n    };\n  }, [show, hideOnScroll, removeTimeout]);\n  var hoverProps = {\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    onTouchStart: function onTouchStart() {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: function onTouchMove() {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: function onTouchEnd() {\n      if (!hasTouchMoved.current && !show) {\n        setShow(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n  return [show, hoverProps, function () {\n    return onMouseLeave(null, true);\n  }];\n}\n/**\r\n * @deprecated\r\n * Note: this component is marked as deprecated and will be removed and a possible\r\n * future release\r\n */\n\n\nfunction Transition(_ref) {\n  var isOpenExternal = _ref.isOpen,\n      children = _ref.children;\n\n  var _useState = useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var didMount = useRef(false);\n  useEffect(function () {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n  useEffect(function () {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(state.isOpenInternal, function () {\n    if (!state.isOpenInternal) {\n      setState(function (s) {\n        return _extends({}, s, {\n          isLeaving: false\n        });\n      });\n    }\n  }, state.isLeaving);\n}\n\nexport { Arrow, DEFAULT_OPTIONS, PLACEMENT_TYPES, Transition, mergeRefs, setGlobalContainer, useHover, useLayer, useMousePositionAsTrigger };","map":{"version":3,"sources":["../src/hooks.ts","../src/util.ts","../src/useTrackElements.ts","../src/useGroup.ts","../src/PlacementType.ts","../src/Sides.ts","../src/BoundsOffsets.ts","../src/Bounds.ts","../src/Placement.ts","../src/getArrowStyle.ts","../src/Placements.ts","../src/SubjectsBounds.ts","../src/useLayer.ts","../src/Arrow.ts","../src/useHover.ts","../src/Transition.ts"],"names":["useTrackRef","onRefChange","storedReference","useRef","element","useMutableStore","initialState","state","useMemo","setter","useEventSubscriptions","subscriptions","unsubscribe","hasEventSubscriptions","removeAllEventSubscriptions","addEventSubscription","useIsomorphicLayoutEffect","useLastState","currentState","enabled","lastState","EMPTY_BOUNDS","top","left","right","bottom","width","height","useMousePositionAsTrigger","preventDefault","parentRef","mouseBounds","setMouseBounds","useState","hasMousePosition","evt","clientX","clientY","resetMousePosition","handleMouseEvent","trigger","getBounds","getParent","undefined","getPixelValue","value","parseFloat","limit","min","max","isSet","mergeRefs","refs","ref","getResizeObserver","environment","polyfill","findScrollContainers","result","document","overflow","overflowX","overflowY","useTrackElements","onChange","ResizeObserverPolyfill","overflowContainer","triggerOption","ResizeObserver","useEffect","arrowRef","hasTriggerOption","Boolean","get","set","scrollContainers","layer","handleChange","useCallback","closestScrollContainer","createReferenceError","scrollOffsets","scrollLeft","scrollTop","scrollX","scrollY","borderOffsets","borderLeftWidth","borderTopWidth","arrow","current","addEventListeners","ignoredInitialCall","observerCallback","observer","listenForScrollElements","resetWhenReferenceChangedWhileTracking","previous","layerRef","previousLayer","getScrollContainers","position","closestScrollContainerHasCorrectStyling","triggerRef","previousTrigger","triggerOptionParent","GroupContext","createContext","GroupProvider","children","registrations","handleRegister","createElement","shouldCloseWhenClickedOutside","useGroup","isOpen","onOutsideClick","onParentClose","possibleRegisterFn","useContext","target","event","clickedOnTrigger","clickedOnLayer","shouldCloseAccordingToChildren","getShouldCloseAccordingToChildren","closeChild","isChild","shouldNotListen","closeOnOutsideClickRefs","PLACEMENT_TYPES","OPPOSITES","center","SideBase","factor","isOppositeDirection","side","recursive","isHorizontal","createSide","prop","BoundSide","Side","SIDES","BoundsOffsets","Object","first","rest","boundsOffsets","boundsOffset","Math","propertyValues","sum","propertyValue","boundsToObject","EMPTY","Bounds","options","withTransform","window","withScrollbars","plain","bounds","boxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","boxWidth","sumOfPropertyValues","boxHeight","scrollbarWidth","scrollbarHeight","innerWidth","innerHeight","toObject","merge","partialBoundsOrMergeFn","substract","entries","boundSide","offsetsTo","child","mapSides","boundSides","mapper","Placement","setSubjectsBounds","dimensions","layerDimensions","subjectBounds","getLayerBounds","secondaryOffset","primary","secondary","subjectsBounds","oppositeCssProp","oppositeSizeProp","opposite","arrowOffsetBase","limitMin","limitMax","propertyA","propertyB","sec","triggerValue","arrowCompensation","layerBounds","triggerHasBiggerWidth","triggerHasBiggerHeight","containerOffsets","mostNegativeSide","a","b","getLayerCollisionBounds","container","offsets","getContainerOffsets","PlacementCenter","sizeProperty","placement","sideA","sideB","offsetA","offsetB","STYLE_BASE","willChange","getArrowStyle","arrowOffset","triggerIsBigger","negativeOffset","getNegativeOffsetBetweenLayerCenterAndTrigger","primarySide","secondarySide","secondaryValue","Placements","type","config","triggerOffset","preferedPlacement","preferredSide","list","placementFrom","getListOfPlacements","filterPlacementsBySide","findFirstPlacementThatFits","placementWithBiggestVisibleSurface","placementWithBiggestSurface","surface","visibleSurface","findSuitablePlacement","getSecondaryOffset","auto","snap","placementsOnSameSide","currentPlacementHasHighestPriority","firstPlacementThatDoesNotFit","secondaryOffsetSide","getStyles","layerStyleBase","getHasDisappeared","subject","hasFullyDisappeared","suitablePlacement","styles","layerSide","hasDisappeared","SubjectsBounds","getTriggerBounds","parent","offsetsToScrollContainers","allContainers","scrollContainer","GLOBAL_CONTAINER","setGlobalContainer","DEFAULT_OPTIONS","containerOffset","possiblePlacements","preferX","preferY","useLayer","onDisappear","setState","triggerBoundsRef","raf","cancelAnimationFrame","handlePositioning","newState","didStateChange","requestAnimationFrame","props","triggerProps","layerProps","style","arrowProps","triggerBounds","renderLayer","createPortal","getContainerElement","next","styleProps","DEFAULT_CONTAINER_ID","LEFT","TOP","BOTTOM","RIGHT","angle","map","sizeA","relativeRoundness","roundness","A","B","cPoint","sizeB","c1A","getWidthBasedOnAngle","c1B","C","d1A","d1B","D","borderOffset","Arrow","forwardRef","size","borderWidth","borderColor","backgroundColor","maxSize","transform","preserveAspectRatio","viewBox","getViewBox","fill","strokeWidth","stroke","d","getTrianglePath","getBorderMaskPath","Status","useHover","delayEnter","delayLeave","hideOnScroll","show","setShow","timeout","status","hasTouchMoved","removeTimeout","clearTimeout","setTimeout","currentTimeout","hoverProps","onMouseEnter","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","Transition","isOpenExternal","isOpenInternal","isLeaving","didMount"],"mappings":"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","sourcesContent":["import {\n  useRef,\n  useMemo,\n  useLayoutEffect,\n  useEffect,\n  MutableRefObject,\n  useState,\n  MouseEvent\n} from \"react\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility hook to track the reference of a html-element.\n * It notifies the listener when a change occured, so it can act\n * on the change\n */\nexport function useTrackRef(\n  onRefChange: (element: HTMLElement) => void\n): (node: HTMLElement | null) => void {\n  const storedReference = useRef<HTMLElement | null>(null);\n\n  // this is de function that actually gets passed to the `ref` prop\n  // on the html element. I.e.:\n  // <div ref={setter} />\n  function setter(element: HTMLElement | null) {\n    if (!element || element === storedReference.current) {\n      return;\n    }\n\n    storedReference.current = element;\n    onRefChange(element);\n  }\n\n  return setter;\n}\n\n/**\n * Utility hook that stores mutable state.\n * Since a getter function is used, it will always return the most\n * up-to-date state. This is useful when you want to get certain state within\n * an effect, without triggering the same effect when the same state changes.\n * Note: may be seen as an anti-pattern.\n */\nexport function useMutableStore<State>(\n  initialState: State\n): readonly [\n  () => State,\n  {\n    (setter: (state: State) => State): void;\n    (setter: State): void;\n  }\n] {\n  const state = useRef<State>(initialState);\n\n  return useMemo(() => {\n    function set(setter: (state: State) => State): void;\n    function set(setter: State): void;\n    function set(setter: any): void {\n      if (typeof setter === \"function\") {\n        state.current = setter(state.current);\n      } else {\n        state.current = setter;\n      }\n    }\n\n    function get() {\n      return state.current;\n    }\n\n    return [get, set] as const;\n  }, []);\n}\n\n/**\n * Utility hook that keeps track of active event listeners and how\n * to remove these listeners\n */\nexport function useEventSubscriptions() {\n  const subscriptions = useRef<Array<() => void>>([]);\n\n  return useMemo(() => {\n    function hasEventSubscriptions() {\n      return subscriptions.current.length > 0;\n    }\n\n    function removeAllEventSubscriptions() {\n      for (const unsubscribe of subscriptions.current!) {\n        unsubscribe();\n      }\n\n      subscriptions.current = [];\n    }\n\n    function addEventSubscription(unsubscriber: () => void) {\n      subscriptions.current.push(unsubscriber);\n    }\n\n    return {\n      hasEventSubscriptions,\n      removeAllEventSubscriptions,\n      addEventSubscription\n    };\n  }, []);\n}\n\n/**\n * SSR-safe effect hook\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Utility hook that tracks an state object.\n * If `enabled=false` it will discard changes and reset the lastState to `null`\n */\nexport function useLastState<T extends unknown>(\n  currentState: T,\n  enabled: boolean\n): MutableRefObject<T | null> {\n  const lastState = useRef<T | null>(currentState);\n\n  if (!enabled) {\n    lastState.current = null;\n    return lastState;\n  }\n\n  lastState.current = currentState;\n  return lastState;\n}\n\nexport type UseMousePositionAsTriggerOptions = {\n  /**\n   * @description Should the position be actively tracked?\n   * @default true\n   */\n  enabled?: boolean;\n  /**\n   * @description Should `handleMouseEvent` preventDefault()?\n   * @default true\n   */\n  preventDefault?: boolean;\n};\n\nexport type UseMousePositionAsTriggerProps = {\n  hasMousePosition: boolean;\n  resetMousePosition: () => void;\n  handleMouseEvent: (evt: MouseEvent) => void;\n  trigger: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n  parentRef: MutableRefObject<any>;\n};\n\nconst EMPTY_BOUNDS: IBounds = {\n  top: 0,\n  left: 0,\n  right: 1,\n  bottom: 1,\n  width: 1,\n  height: 1\n};\n\n/**\n * @description Utility hook that lets you use the mouse-position as source of the trigger.\n * This is useful in scenario's like context-menu's.\n *\n * @example\n * ```tsx\n * const {\n *  hasMousePosition,\n *  resetMousePosition,\n *  handleMouseEvent,\n *  trigger\n *  } = useMousePositionAsTrigger();\n *\n * const { renderLayer, layerProps } = useLayer({\n *  isOpen: hasMousePosition,\n *  trigger,\n *  onOutsideClick: resetMousePosition\n * });\n *\n * return (\n *  <>\n *   {isOpen && renderLayer(<div {...layerProps} />)}\n *   <div onContextMenu={handleMouseEvent} />\n *  </>\n * );\n * ```\n */\nexport function useMousePositionAsTrigger({\n  enabled = true,\n  preventDefault = true\n}: UseMousePositionAsTriggerOptions = {}): UseMousePositionAsTriggerProps {\n  const parentRef = useRef<any>(null);\n\n  const [mouseBounds, setMouseBounds] = useState<IBounds>(EMPTY_BOUNDS);\n\n  function resetMousePosition() {\n    setMouseBounds(EMPTY_BOUNDS);\n  }\n\n  const hasMousePosition = mouseBounds !== EMPTY_BOUNDS;\n\n  function handleMouseEvent(evt: MouseEvent) {\n    if (!enabled) {\n      return;\n    }\n\n    if (preventDefault) {\n      evt.preventDefault();\n    }\n    const { clientX: left, clientY: top } = evt;\n    setMouseBounds({\n      top,\n      left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      bottom: top + 1\n    });\n  }\n\n  return {\n    hasMousePosition,\n    resetMousePosition,\n    handleMouseEvent,\n    trigger: {\n      getBounds: () => mouseBounds!,\n      getParent: parentRef.current ? () => parentRef.current : undefined\n    },\n    parentRef\n  };\n}\n","/**\n * Convert a pixel value into a numeric value\n * @param value string value (ie. '12px')\n */\nexport function getPixelValue(value: string) {\n  return parseFloat(value.replace(\"px\", \"\"));\n}\n\n/**\n * Returns a numeric value that doesn't exceed min or max\n */\nexport function limit(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Utility function which ensures whether a value is truthy\n */\nexport function isSet<T>(value: T | null | undefined): value is T {\n  return value === null || value === undefined ? false : true;\n}\n\n/**\n * Utility function that let's you assign multiple references to a 'ref' prop\n * @param refs list of MutableRefObject's and / or callbacks\n */\nexport function mergeRefs(...refs: any[]) {\n  return (element: HTMLElement | null) => {\n    for (const ref of refs) {\n      if (!ref) {\n        continue;\n      }\n\n      if (typeof ref === \"function\") {\n        ref(element);\n      } else {\n        ref.current = element!;\n      }\n    }\n  };\n}\n","import { useCallback, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\nimport { ResizeObserverClass, ScrollOffsets, BorderOffsets } from \"./types\";\nimport {\n  useTrackRef,\n  useMutableStore,\n  useEventSubscriptions,\n  useIsomorphicLayoutEffect\n} from \"./hooks\";\nimport { getPixelValue } from \"./util\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility to get the correct ResizeObserver class\n */\nexport function getResizeObserver(\n  environment: Window | undefined,\n  polyfill: ResizeObserverClass | undefined\n): ResizeObserverClass | undefined {\n  if (typeof environment === \"undefined\") {\n    return undefined;\n  }\n\n  return polyfill || (environment as any).ResizeObserver;\n}\n\n/**\n * Utility function that given a element traverses up in the html-hierarchy\n * to find and return all ancestors that have scroll behavior\n */\nexport function findScrollContainers(\n  element: HTMLElement | null,\n  environment?: Window\n): HTMLElement[] {\n  const result: HTMLElement[] = [];\n\n  if (!element || !environment || element === document.body) {\n    return result;\n  }\n\n  const { overflow, overflowX, overflowY } = environment.getComputedStyle(\n    element\n  );\n\n  if (\n    [overflow, overflowX, overflowY].some(prop =>\n      [\"auto\", \"scroll\"].includes(prop)\n    )\n  ) {\n    result.push(element);\n  }\n\n  return [\n    ...result,\n    ...findScrollContainers(element.parentElement, environment)\n  ];\n}\n\nfunction createReferenceError(subject: string) {\n  return `react-laag: Could not find a valid reference for the ${subject} element. There might be 2 causes:\n   - Make sure that the 'ref' is set correctly on the ${subject} element when isOpen: true. Also make sure your component forwards the ref with \"forwardRef()\".\n   - Make sure that you are actually rendering the ${subject} when the isOpen prop is set to true`;\n}\n\nexport type OnChangeElements = {\n  layer: HTMLElement;\n  trigger: HTMLElement;\n  arrow: HTMLElement | null;\n  scrollContainers: HTMLElement[];\n};\n\nexport type UseTrackElementsProps = {\n  enabled: boolean;\n  onChange: (\n    elements: OnChangeElements,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ) => void;\n  environment: Window | undefined;\n  ResizeObserverPolyfill: ResizeObserverClass | undefined;\n  overflowContainer: boolean;\n  triggerOption?: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n};\n\ntype UseTrackElementsReturnValue = {\n  triggerRef: (element: HTMLElement | null) => void;\n  layerRef: (element: HTMLElement | null) => void;\n  arrowRef: React.MutableRefObject<HTMLElement | null>;\n  closestScrollContainer: HTMLElement | null;\n};\n\n/**\n * This hook has the responsibility to track the bounds of:\n * - the trigger element\n * - the layer element\n * - the arrow element\n * - the scroll-containers of which the trigger element is a descendant of\n *\n * It will call the `onChange` callback with a collection of these elements when any\n * of the tracked elements bounds have changed\n *\n * It will detect these changes by listening:\n * - when the reference of the trigger element changes\n * - when the reference of the layer element changes\n * - when the trigger, layer or document body changes in size\n * - when the user scrolls the page, or any of the scroll containers\n */\nexport function useTrackElements({\n  // should we track the bounds?\n  enabled,\n  // call this callback when the bounds have changed\n  onChange,\n  // optional environment (i.e. when using iframes)\n  environment,\n  // optionally inject a polyfill when the browser does not support it\n  // out of the box\n  ResizeObserverPolyfill,\n  // behavior will alter slightly when `overflowContainer` is enabled\n  overflowContainer,\n  // the optional trigger-option provided by the user\n  triggerOption\n}: UseTrackElementsProps): UseTrackElementsReturnValue {\n  // get the correct reference to the ResizeObserver class\n  const ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill);\n\n  // warn the user when no valid ResizeObserver class could be found\n  useEffect(() => {\n    warning(\n      ResizeObserver,\n      `This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://link`\n    );\n  }, [ResizeObserver]);\n\n  // keep reference of the optional arrow-component\n  const arrowRef = useRef<HTMLElement | null>(null);\n\n  // if user has provided the trigger-option we should ingore certain things elsewhere\n  const hasTriggerOption = Boolean(triggerOption);\n\n  // Keep track of mutable element related state\n  // It is generally better to use React.useState, but unfortunately that causes to many re-renders\n  const [get, set] = useMutableStore<{\n    scrollContainers: HTMLElement[];\n    trigger: HTMLElement | null;\n    layer: HTMLElement | null;\n  }>({\n    scrollContainers: [],\n    trigger: null,\n    layer: null\n  });\n\n  // utility to keep track of the scroll and resize listeners and how to unsubscribe them\n  const {\n    hasEventSubscriptions,\n    addEventSubscription,\n    removeAllEventSubscriptions\n  } = useEventSubscriptions();\n\n  // All scroll and resize changes eventually end up here, where the collection of bounds (subjectsBounds) is\n  // constructed in order to notifiy the `onBoundsChange` callback\n  const handleChange = useCallback(\n    function handleChange() {\n      const { layer, trigger, scrollContainers } = get();\n      const closestScrollContainer = scrollContainers[0];\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      // ignore when user has provided the trigger-option\n      if (!trigger && !hasTriggerOption) {\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      let scrollOffsets: ScrollOffsets = { top: 0, left: 0 };\n      if (closestScrollContainer) {\n        const { scrollLeft, scrollTop } = closestScrollContainer;\n        scrollOffsets = {\n          top: scrollTop,\n          left: scrollLeft\n        };\n      } else {\n        const { scrollX, scrollY } = environment!;\n        scrollOffsets = {\n          top: scrollY,\n          left: scrollX\n        };\n      }\n\n      let borderOffsets: BorderOffsets = { left: 0, top: 0 };\n      if (closestScrollContainer) {\n        const {\n          borderLeftWidth,\n          borderTopWidth\n        } = environment!.getComputedStyle(closestScrollContainer);\n\n        borderOffsets = {\n          left: getPixelValue(borderLeftWidth) || 0,\n          top: getPixelValue(borderTopWidth) || 0\n        };\n      }\n\n      onChange(\n        {\n          layer,\n          trigger: trigger!,\n          scrollContainers,\n          arrow: arrowRef.current\n        },\n        scrollOffsets,\n        borderOffsets\n      );\n    },\n    [get, onChange, environment, arrowRef, hasTriggerOption]\n  );\n\n  // responsible for adding the scroll and resize listeners to the correct\n  // html elements\n  const addEventListeners = useCallback(\n    function addEventListeners() {\n      const { trigger, layer, scrollContainers } = get();\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      if (!trigger && !hasTriggerOption) {\n        // ignore when user has provided the trigger-option\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      if (ResizeObserver) {\n        let ignoredInitialCall = false;\n        const observerCallback = () => {\n          if (!ignoredInitialCall) {\n            ignoredInitialCall = true;\n            return;\n          }\n\n          handleChange();\n        };\n\n        const observer = new ResizeObserver(observerCallback);\n        for (const element of [trigger, layer, document.body]) {\n          if (element) observer.observe(element);\n        }\n\n        addEventSubscription(() => {\n          for (const element of [trigger, layer, document.body]) {\n            if (element) observer.unobserve(element);\n          }\n          observer.disconnect();\n        });\n      }\n\n      const listenForScrollElements = [environment!, ...scrollContainers];\n      for (const element of listenForScrollElements) {\n        element.addEventListener(\"scroll\", handleChange);\n\n        addEventSubscription(() =>\n          element.removeEventListener(\"scroll\", handleChange)\n        );\n      }\n    },\n    [\n      get,\n      addEventSubscription,\n      handleChange,\n      environment,\n      ResizeObserver,\n      hasTriggerOption\n    ]\n  );\n\n  // when either the reference to the trigger or layer element changes\n  // we should reset the event listeners and trigger a `onChange`\n  const resetWhenReferenceChangedWhileTracking = useCallback(\n    (previous: HTMLElement | null, next: HTMLElement) => {\n      if (enabled && previous && previous !== next) {\n        removeAllEventSubscriptions();\n        addEventListeners();\n        handleChange();\n      }\n    },\n    [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]\n  );\n\n  // Logic when reference to layer changes\n  const layerRef = useTrackRef(\n    useCallback(\n      layer => {\n        const { layer: previousLayer } = get();\n\n        // store new reference\n        set(state => ({\n          ...state,\n          layer\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousLayer, layer);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking]\n    )\n  );\n\n  const getScrollContainers = useCallback(\n    function handleScrollContainers(element: HTMLElement) {\n      const scrollContainers = findScrollContainers(element, environment);\n\n      const closestScrollContainer = scrollContainers[0];\n\n      if (closestScrollContainer) {\n        // Check if we should warn the user about 'position: relative; stuff...'\n        const position = environment!.getComputedStyle(closestScrollContainer)\n          .position;\n\n        const closestScrollContainerHasCorrectStyling =\n          [\"relative\", \"absolute\", \"fixed\"].includes(position) ||\n          overflowContainer;\n\n        if (!closestScrollContainerHasCorrectStyling) {\n          closestScrollContainer.style.position = \"relative\";\n        }\n\n        warning(\n          closestScrollContainerHasCorrectStyling,\n          `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: \"${position}\". For now, \"position: relative;\" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.`\n        );\n      }\n      return scrollContainers;\n    },\n    [environment, overflowContainer]\n  );\n\n  // Logic when reference to trigger changes\n  // Note: this will have no effect when user provided the trigger-option\n  const triggerRef = useTrackRef(\n    useCallback(\n      trigger => {\n        // collect list of scroll containers\n        const scrollContainers = getScrollContainers(trigger);\n\n        const { trigger: previousTrigger } = get();\n\n        // store new references\n        set(state => ({\n          ...state,\n          trigger,\n          scrollContainers\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers]\n    )\n  );\n\n  // when user has provided the trigger-option, it monitors the optional parent-element\n  // in order to determine the scroll-containers\n  const triggerOptionParent = triggerOption?.getParent?.();\n  useIsomorphicLayoutEffect(() => {\n    if (!triggerOptionParent) {\n      return;\n    }\n    set(state => ({\n      ...state,\n      scrollContainers: getScrollContainers(triggerOptionParent)\n    }));\n  }, [triggerOptionParent, set, getScrollContainers]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // add event listeners if necessary\n      if (!hasEventSubscriptions()) {\n        addEventListeners();\n      }\n    }\n\n    return () => {\n      if (hasEventSubscriptions()) {\n        removeAllEventSubscriptions();\n      }\n    };\n  }, [\n    enabled,\n    hasEventSubscriptions,\n    addEventListeners,\n    removeAllEventSubscriptions\n  ]);\n\n  // run this effect after every render\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // eventually call `handleChange` with latest elements-refs\n      handleChange();\n    }\n  });\n\n  return {\n    triggerRef,\n    layerRef,\n    arrowRef,\n    closestScrollContainer: get().scrollContainers[0] || null\n  };\n}\n","import {\n  ReactNode,\n  createContext,\n  MutableRefObject,\n  useCallback,\n  useRef,\n  useContext,\n  useEffect,\n  createElement\n} from \"react\";\nimport warning from \"tiny-warning\";\n\ntype Registration = {\n  shouldCloseWhenClickedOutside: (event: MouseEvent) => boolean;\n  closeChild: () => void;\n};\n\ntype Registrations = Set<Registration>;\n\ntype RegisterFn = (registration: Registration) => () => void;\n\ntype GroupContextType = {} | RegisterFn;\n\nconst GroupContext = createContext({} as GroupContextType);\n\ntype GroupProviderProps = {\n  children: ReactNode;\n  registrations: MutableRefObject<Registrations>;\n};\n\n// Provider that wraps arround the layer in order to provide other useLayers\n// down in the hiearchy (child layers) with means to communicate with the parent.\n// This provider receives a `registrations` Set which can be used to add and\n// delete registrations.\nexport function GroupProvider({ children, registrations }: GroupProviderProps) {\n  // registration function that is used as 'context payload' for child layers\n  // to call. It returns a function to unregister.\n  const handleRegister = useCallback(\n    function register(registration: Registration) {\n      registrations.current.add(registration);\n\n      return () => registrations.current.delete(registration);\n    },\n    [registrations]\n  );\n\n  return createElement(\n    GroupContext.Provider,\n    { value: handleRegister },\n    children\n  );\n}\n\n// asks child layers if they would close given the documents click event\n// if there's one that signals not to close, return early (false)\nfunction getShouldCloseAccordingToChildren(\n  registrations: Registrations,\n  event: MouseEvent\n) {\n  for (const { shouldCloseWhenClickedOutside } of registrations) {\n    if (!shouldCloseWhenClickedOutside(event)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype UseGroup = {\n  isOpen: boolean;\n  onOutsideClick?: () => void;\n  onParentClose?: () => void;\n};\n\n/**\n * Responsible for close behavior\n * When the `onOutsideClick` callback is provided by the user, it will listen for clicks\n * in the document, and tell whether the user clicked outside -> not on layer / trigger.\n * It keeps track of nested useLayers a.k.a child layers (`registrations` Set), through which\n * we can ask whether they `shouldCloseWhenClickedOutside`, or tell them to close.\n *\n * Behavior:\n * - `onOutsideClick` only works on the most outer parent, and not on children. The parent will ask\n *   the child layers whether they would close, and will handle accordingly. The parent may\n *   command the children to close indirectly with the help of `onParentClose`\n * - When the parent just was closed, it will make sure that any children will also close\n *   with the help of `onParentClose`\n */\nexport function useGroup({ isOpen, onOutsideClick, onParentClose }: UseGroup) {\n  // store references to the dom-elements\n  // we need these to later determine wether the clicked outside or not\n  const trigger = useRef<HTMLElement>(null!);\n  const layer = useRef<HTMLElement>(null!);\n\n  // a Set which keeps track of callbacks given by the child layers through context\n  const registrations = useRef<Registrations>(new Set());\n\n  // if this instance is a child itself, we should use this function to register\n  // some callbacks to the parent\n  const possibleRegisterFn = useContext(GroupContext);\n\n  // recursively checks whether to close or not. This mechanism has some similarities\n  // with event bubbling.\n  const shouldCloseWhenClickedOutside = useCallback(\n    function shouldCloseWhenClickedOutside(event: MouseEvent) {\n      const target = event.target as HTMLElement;\n\n      const clickedOnTrigger =\n        trigger.current && trigger.current.contains(target);\n      const clickedOnLayer = layer.current && layer.current.contains(target);\n\n      const shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(\n        registrations.current,\n        event\n      );\n\n      // when clicked on own layer, but the child would have closed ->\n      // let child close\n      if (clickedOnLayer && shouldCloseAccordingToChildren) {\n        registrations.current.forEach(({ closeChild }) => closeChild());\n      }\n\n      return (\n        !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren\n      );\n    },\n    [trigger, layer, registrations]\n  );\n\n  // registration stuff\n  useEffect(() => {\n    if (typeof possibleRegisterFn !== \"function\") {\n      return;\n    }\n\n    // 'possibleRegisterFn' will return a function that will unregister\n    // on cleanup\n    return possibleRegisterFn({\n      shouldCloseWhenClickedOutside,\n      closeChild: () => {\n        warning(\n          onParentClose,\n          `react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.`\n        );\n\n        if (onParentClose) {\n          onParentClose();\n        }\n      }\n    });\n  }, [\n    possibleRegisterFn,\n    shouldCloseWhenClickedOutside,\n    onParentClose,\n    registrations\n  ]);\n\n  // document click handling\n  useEffect(() => {\n    const isChild = typeof possibleRegisterFn === \"function\";\n    const shouldNotListen = !isOpen || !onOutsideClick || isChild;\n    if (shouldNotListen) {\n      return;\n    }\n\n    function handleClick(event: MouseEvent) {\n      if (shouldCloseWhenClickedOutside(event)) {\n        onOutsideClick!();\n      }\n    }\n\n    document.addEventListener(\"click\", handleClick, true);\n    return () => document.removeEventListener(\"click\", handleClick, true);\n  }, [\n    isOpen,\n    onOutsideClick,\n    shouldCloseWhenClickedOutside,\n    possibleRegisterFn\n  ]);\n\n  // When this 'useLayer' gets closed -> tell child layers to close as well\n  useEffect(() => {\n    if (!isOpen) {\n      registrations.current.forEach(({ closeChild }) => closeChild());\n    }\n  }, [isOpen]);\n\n  return {\n    closeOnOutsideClickRefs: {\n      trigger,\n      layer\n    },\n    registrations\n  };\n}\n","export const PLACEMENT_TYPES: PlacementType[] = [\n  \"bottom-start\",\n  \"bottom-end\",\n  \"bottom-center\",\n  \"top-start\",\n  \"top-center\",\n  \"top-end\",\n  \"left-end\",\n  \"left-center\",\n  \"left-start\",\n  \"right-end\",\n  \"right-center\",\n  \"right-start\",\n  \"center\"\n];\n\nexport type PlacementType =\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"bottom-center\"\n  | \"top-start\"\n  | \"top-center\"\n  | \"top-end\"\n  | \"left-end\"\n  | \"left-center\"\n  | \"left-start\"\n  | \"right-end\"\n  | \"right-center\"\n  | \"right-start\"\n  | \"center\";\n","export type BoundSideProp = \"top\" | \"left\" | \"bottom\" | \"right\";\nexport type SideProp = BoundSideProp | \"center\";\ntype SizeProp = \"width\" | \"height\";\ntype CssProp = \"top\" | \"left\";\n\nconst OPPOSITES: Record<SideProp, SideProp> = {\n  top: \"bottom\",\n  left: \"right\",\n  bottom: \"top\",\n  right: \"left\",\n  center: \"center\"\n};\n\nclass SideBase<T extends SideProp> {\n  constructor(\n    readonly prop: T,\n    readonly opposite: SideBase<T>,\n    readonly isHorizontal: boolean,\n    readonly sizeProp: SizeProp,\n    readonly oppositeSizeProp: SizeProp,\n    readonly cssProp: CssProp,\n    readonly oppositeCssProp: CssProp,\n    readonly isCenter: boolean,\n    readonly isPush: boolean // left | top\n  ) {}\n\n  factor(value: number) {\n    return value * (this.isPush ? 1 : -1);\n  }\n\n  isOppositeDirection(side: SideBase<any>) {\n    return this.isHorizontal !== side.isHorizontal;\n  }\n}\n\nfunction createSide<T extends SideProp>(\n  prop: T,\n  recursive = true\n): SideBase<T> {\n  const isHorizontal = [\"left\", \"right\"].includes(prop);\n\n  return new SideBase<T>(\n    prop,\n    recursive ? createSide<T>((OPPOSITES as any)[prop], false) : null!,\n    isHorizontal,\n    isHorizontal ? \"width\" : \"height\",\n    isHorizontal ? \"height\" : \"width\",\n    isHorizontal ? \"left\" : \"top\",\n    isHorizontal ? \"top\" : \"left\",\n    prop === \"center\",\n    ![\"right\", \"bottom\"].includes(prop)\n  );\n}\n\nexport type BoundSideType = SideBase<BoundSideProp>;\nexport type SideType = SideBase<SideProp>;\n\nexport const BoundSide = {\n  top: createSide(\"top\") as BoundSideType,\n  bottom: createSide(\"bottom\") as BoundSideType,\n  left: createSide(\"left\") as BoundSideType,\n  right: createSide(\"right\") as BoundSideType\n};\n\nexport const Side = {\n  ...(BoundSide as {\n    top: SideType;\n    left: SideType;\n    bottom: SideType;\n    right: SideType;\n  }),\n  center: createSide(\"center\")\n};\n","export interface IBoundsOffsets {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n}\n\nconst SIDES = [\"top\", \"left\", \"bottom\", \"right\"] as (keyof IBoundsOffsets)[];\n\n/**\n * A class containing the positional properties which represent the distance\n * between two Bounds instances for each side\n */\nexport class BoundsOffsets implements IBoundsOffsets {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n\n  constructor(offsets: IBoundsOffsets) {\n    return Object.assign(this, offsets);\n  }\n\n  /**\n   * Takes multiple BoundsOffets instances and creates a new BoundsOffsets instance\n   * by taking the smallest value for each side\n   * @param boundsOffsets list of BoundsOffsets instances\n   */\n  static mergeSmallestSides(boundsOffsets: BoundsOffsets[]): BoundsOffsets {\n    const [first, ...rest] = boundsOffsets;\n\n    if (!first) {\n      throw new Error(\n        \"Please provide at least 1 bounds objects in order to merge\"\n      );\n    }\n\n    const result: IBoundsOffsets = Object.fromEntries(\n      SIDES.map(side => [side, first[side]])\n    ) as any;\n\n    for (const boundsOffset of rest) {\n      for (const side of SIDES) {\n        result[side] = Math.min(result[side], boundsOffset[side]);\n      }\n    }\n\n    return new BoundsOffsets(result);\n  }\n\n  /**\n   * Checks whether all sides sides are positive, meaning the corresponding Bounds instance\n   * fits perfectly within a parent Bounds instance\n   */\n  get allSidesArePositive(): boolean {\n    return SIDES.every(side => this[side] >= 0);\n  }\n\n  /**\n   * Returns a partial IBoundsOffsets with sides that are negative, meaning sides aren't entirely\n   * visible in respect to a parent Bounds instance\n   */\n  get negativeSides(): Partial<IBoundsOffsets> {\n    return Object.fromEntries(\n      SIDES.filter(side => this[side] < 0).map(side => [side, this[side]])\n    ) as Partial<IBoundsOffsets>;\n  }\n}\n","import { BoundSide, BoundSideProp, BoundSideType } from \"./Sides\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { getPixelValue } from \"./util\";\n\n/**\n * Utility function that returns sum of various computed styles\n * @param propertyValues list of computed styles (ie. '12px')\n */\nfunction sumOfPropertyValues(...propertyValues: string[]) {\n  return propertyValues.reduce(\n    (sum, propertyValue) =>\n      sum + (propertyValue ? getPixelValue(propertyValue!) : 0),\n    0\n  );\n}\n\nexport interface IBounds {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}\n\nexport function boundsToObject({\n  top,\n  left,\n  right,\n  bottom,\n  width,\n  height\n}: IBounds): IBounds {\n  return { top, left, right, bottom, width, height };\n}\n\nconst EMPTY: IBounds = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: 0,\n  height: 0\n};\n\n/**\n * A class containing the positional properties of the native DOM's ClientRect\n * (`element.getBoundingClientRect()`), together with some utility methods\n */\nexport class Bounds implements IBounds {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n  width!: number;\n  height!: number;\n\n  /**\n   * Creates a new Bounds class\n   * @param bounds An object that adheres to the `IBounds` interface\n   */\n  static create(bounds: IBounds): Bounds {\n    return new Bounds(bounds);\n  }\n\n  /**\n   * Creates a new Bounds class from a DOM-element\n   * @param element reference to the DOM-element\n   * @param options optional options object\n   */\n  static fromElement(\n    element: HTMLElement,\n    options: {\n      /** should transforms like 'scale' taken into account? Defaults to `true` */\n      withTransform?: boolean;\n      /** reference to the window-object (needed when working with iframes for instance). Defaults to `window` */\n      environment?: Window;\n      /** should the elements scrollbars be included? Defaults to `true` */\n      withScrollbars?: boolean;\n    } = {}\n  ): Bounds {\n    const {\n      withTransform = true,\n      environment = window,\n      withScrollbars = true\n    } = options;\n\n    const plain: IBounds = boundsToObject(element.getBoundingClientRect());\n\n    let bounds: Bounds = new Bounds(plain);\n\n    if (!withTransform) {\n      const {\n        width,\n        height,\n        boxSizing,\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        paddingLeft,\n        paddingRight,\n        paddingTop,\n        paddingBottom\n      } = environment.getComputedStyle(element);\n\n      const boxWidth =\n        boxSizing === \"border-box\"\n          ? getPixelValue(width!)\n          : sumOfPropertyValues(\n              width,\n              borderLeft,\n              borderRight,\n              paddingLeft,\n              paddingRight\n            );\n\n      const boxHeight =\n        boxSizing === \"border-box\"\n          ? getPixelValue(height!)\n          : sumOfPropertyValues(\n              height,\n              borderTop,\n              borderBottom,\n              paddingTop,\n              paddingBottom\n            );\n\n      bounds = new Bounds({\n        ...bounds,\n        width: boxWidth,\n        height: boxHeight\n      });\n    }\n\n    if (!withScrollbars) {\n      const scrollbarWidth = bounds.width - element.clientWidth;\n      const scrollbarHeight = bounds.height - element.clientHeight;\n      return bounds.substract({\n        right: scrollbarWidth,\n        bottom: scrollbarHeight\n      });\n    }\n\n    return bounds;\n  }\n\n  /**\n   * Creates an empty Bounds class\n   */\n  static empty(): Bounds {\n    return new Bounds();\n  }\n\n  /**\n   * Creates a Bounds class from the window's dimensions\n   * @param environment reference to the window-object (needed when working with iframes for instance). Defaults to `window`\n   */\n  static fromWindow(environment?: Window): Bounds {\n    const { innerWidth: width = 0, innerHeight: height = 0 } =\n      environment || {};\n    return new Bounds({ width, height, right: width, bottom: height });\n  }\n\n  protected constructor(bounds: Partial<IBounds> = {}) {\n    return Object.assign(this, EMPTY, bounds);\n  }\n\n  /**\n   * Returns the square surface of the bounds in pixels\n   */\n  get surface(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * Returns a plain object containing only positional properties\n   */\n  toObject(): IBounds {\n    return boundsToObject(this);\n  }\n\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param bounds partial bounds which should be merged\n   */\n  merge(bounds: Partial<IBounds>): Bounds;\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param mergeFn callback which takes the current bounds and returns new merged bounds\n   */\n  merge(mergeFn: (current: IBounds) => Partial<IBounds>): Bounds;\n  merge(partialBoundsOrMergeFn: unknown): Bounds {\n    const current = this.toObject();\n    return new Bounds({\n      ...current,\n      ...(typeof partialBoundsOrMergeFn === \"function\"\n        ? partialBoundsOrMergeFn(current)\n        : partialBoundsOrMergeFn)\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by subtracting each property of the provided IBounds object\n   * @param bounds partial IBounds object to substract with\n   */\n  substract(bounds: Partial<IBounds>): Bounds {\n    const result = this.toObject();\n\n    const entries = Object.entries(bounds) as [keyof IBounds, number][];\n\n    for (const [prop, value] of entries) {\n      if (prop in BoundSide) {\n        // if `prop` is one of 'top', 'left', 'bottom' or 'right'...\n        const boundSide = BoundSide[prop as BoundSideProp];\n        // decide if we should add or substract\n        result[prop] += boundSide.factor(value);\n        // make sure that the size-properties are also updated\n        result[boundSide.isHorizontal ? \"width\" : \"height\"] -= value;\n      } else {\n        // prop is 'width' or 'height'\n        result[prop] -= value || 0;\n      }\n    }\n\n    return new Bounds(result);\n  }\n\n  /**\n   * Returns a new BoundsOffsets instance by determining the distance for each bound-side:\n   * (child -> parent)\n   * @param child child bounds instance\n   */\n  offsetsTo(child: Bounds): BoundsOffsets {\n    return new BoundsOffsets({\n      top: child.top - this.top,\n      bottom: this.bottom - child.bottom,\n      left: child.left - this.left,\n      right: this.right - child.right\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by mapping over each bound-side\n   * @param mapper callback that takes a boundSide + value in pixels, returning a new value for that side\n   */\n  mapSides(\n    mapper: (boundSide: BoundSideType, value: number) => number\n  ): Bounds {\n    const result = this.toObject();\n    const boundSides = Object.values(BoundSide) as BoundSideType[];\n    for (const boundSide of boundSides) {\n      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);\n    }\n    return new Bounds(result);\n  }\n}\n","import { BoundSideType, SideType, BoundSide, BoundSideProp } from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { PositionConfig, Offsets } from \"./types\";\nimport { Bounds, IBounds } from \"./Bounds\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { limit } from \"./util\";\n\n/**\n * Class for various calculations based on a placement-type. I.e 'top-left';\n */\nexport class Placement {\n  protected subjectsBounds!: SubjectsBounds;\n  private _cachedLayerBounds: Bounds | null = null;\n  private _cachedContainerOffsets: BoundsOffsets | null = null;\n\n  constructor(\n    public readonly primary: SideType,\n    public readonly secondary: SideType,\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"],\n    private readonly offsets: Offsets\n  ) {\n    this.setSubjectsBounds(subjectBounds, layerDimensions);\n  }\n\n  /**\n   * Set subjectsBounds that are specific for this placement\n   * @param subjectBounds original SubjectBounds instance\n   * @param layerDimensions possible config prodvided by the user\n   */\n  private setSubjectsBounds(\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"]\n  ): void {\n    // if user did not provide any layerDimensions config...\n    if (!layerDimensions) {\n      this.subjectsBounds = subjectBounds;\n      return;\n    }\n\n    // get anticipated layer-dimensions provided by the user\n    const dimensions =\n      // if the user passed a callback, call it with the layerSide corresponding to\n      // the placement\n      typeof layerDimensions === \"function\"\n        ? layerDimensions(this.primary.prop)\n        : layerDimensions;\n\n    // create new SubjectsBounds instance by merging our newly create layer-bounds\n    this.subjectsBounds = subjectBounds.merge({\n      layer: {\n        ...subjectBounds.layer,\n        ...dimensions\n      }\n    });\n  }\n\n  /**\n   * Returns the string respresentation of this placement (ie. 'top-start')\n   */\n  public get type(): PlacementType {\n    return `${this.primary.prop}-${\n      this.secondary.prop === \"center\"\n        ? \"center\"\n        : [\"bottom\", \"right\"].includes(this.secondary.prop)\n        ? \"end\"\n        : \"start\"\n    }` as PlacementType;\n  }\n\n  /**\n   * Calculates the actual boundaries based on the placement\n   * @param secondaryOffset optional offset on the secondary-side\n   */\n  public getLayerBounds(secondaryOffset = 0): Bounds {\n    // return cached version if possible\n    if (this._cachedLayerBounds && secondaryOffset === 0) {\n      return this._cachedLayerBounds;\n    }\n\n    const { primary, secondary, subjectsBounds } = this;\n    const { trigger, layer, arrow } = subjectsBounds;\n    const {\n      isHorizontal,\n      oppositeCssProp,\n      oppositeSizeProp,\n      prop,\n      opposite\n    } = primary as BoundSideType;\n\n    const result = Bounds.empty() as IBounds;\n\n    // let's take the placement 'top-start' as an example...\n    // the offsets are the following:\n    // trigger -> 8px\n    // container -> 10px;\n    // arrow -> 2px;\n\n    // PRIMARY STUFF\n\n    // bottom = trigger.top + 8;\n    result[opposite.prop] =\n      trigger[prop] - primary.factor(this.offsets.trigger);\n\n    // top = bottom - layer.height\n    result[prop] =\n      result[opposite.prop] - primary.factor(layer[primary.sizeProp]);\n\n    // SECONDARY STUFF\n\n    // arrowOffsetBase = 4\n    const arrowOffsetBase = this.offsets.arrow * 2;\n\n    // limitMin = trigger.left - (layer.width - arrow.width) + 4\n    let limitMin =\n      trigger[oppositeCssProp] -\n      (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) +\n      arrowOffsetBase;\n    // limitMax = trigger.left + (trigger.width - arrow.width) - 4\n    let limitMax =\n      trigger[oppositeCssProp] +\n      (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) -\n      arrowOffsetBase;\n\n    if (!secondary.isPush) {\n      // if secondary is bottom or right -> add the width or height of the layer\n      limitMin += layer[oppositeSizeProp];\n      limitMax += layer[oppositeSizeProp];\n    }\n\n    if (secondary.isCenter) {\n      const propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;\n      const propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right)\n        .prop;\n\n      // left = limit(\n      //   trigger.left + trigger.width / 2 - layer.width / 2 + secondaryOffset,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[propertyA] = limit(\n        trigger[propertyA] +\n          trigger[oppositeSizeProp] / 2 -\n          layer[oppositeSizeProp] / 2 +\n          secondaryOffset,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];\n    } else {\n      const sec = secondary as BoundSideType;\n\n      const triggerValue = trigger[sec.prop];\n\n      // Under some conditions, when the layer is not able to align with the trigger\n      // due to arrow-size and arrow-offsets, we need to compensate.\n      // Otherwise, the secondary-offset will have no impact\n      const arrowCompensation =\n        triggerValue < limitMin\n          ? limitMin - triggerValue\n          : triggerValue > limitMax\n          ? limitMax - triggerValue\n          : 0;\n\n      // left = limit(\n      //   trigger.left + secondaryOffset + arrowCompensation,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[sec.prop] = limit(\n        triggerValue + secondaryOffset + arrowCompensation,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[sec.opposite.prop] =\n        result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);\n    }\n\n    // set the correct dimensions\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    // create new bounds object\n    const layerBounds = Bounds.create(result);\n\n    if (secondaryOffset === 0) {\n      this._cachedLayerBounds = layerBounds;\n    }\n\n    return layerBounds;\n  }\n\n  /**\n   * Checks whether the trigger is bigger on the opposite side\n   * ie. placement \"top-start\" -> has trigger a bigger width?\n   */\n  public get triggerIsBigger() {\n    const { isHorizontal } = this.secondary;\n    const {\n      triggerHasBiggerWidth,\n      triggerHasBiggerHeight\n    } = this.subjectsBounds;\n\n    return (\n      (isHorizontal && triggerHasBiggerWidth) ||\n      (!isHorizontal && triggerHasBiggerHeight)\n    );\n  }\n\n  /**\n   * Checks whether the placement fits within all it's container (including container-offset)\n   */\n  public get fitsContainer(): boolean {\n    return this.getContainerOffsets().allSidesArePositive;\n  }\n\n  /**\n   * Returns the surface in square pixels of the visible part of the layer\n   */\n  public get visibleSurface(): number {\n    const layerBounds = this.getLayerBounds();\n    const containerOffsets = this.getContainerOffsets(layerBounds);\n\n    const substract = containerOffsets.negativeSides;\n    for (const side in substract) {\n      // @ts-ignore\n      substract[side] = -substract[side]; // make positive for substraction;\n    }\n\n    return layerBounds.substract(substract).surface;\n  }\n\n  /**\n   * Returns a BoundSide by looking at the most negative offset that is the opposite direction\n   */\n  public get secondaryOffsetSide(): BoundSideType | null {\n    // Given placement 'top-start' and containerOffsets { left: -20, top: -10, right: -10, bottom: 200 }...\n    // the only negative offsets on the opposite side are { left: -20, right: -10 }\n    // since we have to return only 1 side, we pick the most negative, which is 'left'\n\n    const containerOffsets = this.getContainerOffsets();\n\n    const [mostNegativeSide] =\n      Object.entries(containerOffsets.negativeSides)\n        .map(\n          ([side, value]) => [BoundSide[side as BoundSideProp], value] as const\n        )\n        .filter(([side]) => this.primary.isOppositeDirection(side))\n        .sort(([, a], [, b]) => b! - a!)?.[0] ?? [];\n\n    return mostNegativeSide || null;\n  }\n\n  /**\n   * returns getLayerBounds(), including container-offsets\n   */\n  private getLayerCollisionBounds(): Bounds {\n    const { container } = this.offsets;\n\n    return this.getLayerBounds()\n      .mapSides((side, value) => (value -= side.factor(container)))\n      .merge(({ width, height }) => ({\n        width: width + container * 2,\n        height: height + container * 2\n      }));\n  }\n\n  /**\n   * Returns a BoundsOffsets instance containing merged offsets to containers with the most\n   * negative scenario\n   */\n  public getContainerOffsets(layerBounds?: Bounds): BoundsOffsets {\n    if (this._cachedContainerOffsets && !layerBounds) {\n      return this._cachedContainerOffsets;\n    }\n\n    const subjectBounds = this.subjectsBounds.merge({\n      layer: layerBounds || this.getLayerCollisionBounds()\n    });\n\n    const offsets = BoundsOffsets.mergeSmallestSides(\n      subjectBounds.layerOffsetsToScrollContainers\n    );\n\n    if (!layerBounds) {\n      this._cachedContainerOffsets = offsets;\n    }\n\n    return offsets;\n  }\n}\n\nexport class PlacementCenter extends Placement {\n  getLayerBounds(): Bounds {\n    const { trigger, layer } = this.subjectsBounds;\n\n    const result = Bounds.empty() as IBounds;\n\n    result.top = trigger.top + trigger.height / 2 - layer.height / 2;\n    result.bottom = result.top + layer.height;\n    result.left = trigger.left + trigger.width / 2 - layer.width / 2;\n    result.right = result.left + layer.width;\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    return result as Bounds;\n  }\n}\n","import { limit } from \"./util\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { Placement } from \"./Placement\";\n\n// how much pixels is the center of layer removed from edge of trigger?\nfunction getNegativeOffsetBetweenLayerCenterAndTrigger(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n) {\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n\n  const [sideA, sideB] = !placement.primary.isHorizontal\n    ? ([\"left\", \"right\"] as const)\n    : ([\"top\", \"bottom\"] as const);\n\n  const offsetA =\n    layer[sideA] +\n    layer[sizeProperty] / 2 -\n    trigger[sideA] -\n    arrow[sizeProperty] / 2 -\n    arrowOffset;\n  const offsetB =\n    layer[sideB] -\n    layer[sizeProperty] / 2 -\n    trigger[sideB] +\n    arrow[sizeProperty] / 2 +\n    arrowOffset;\n\n  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);\n}\n\nconst STYLE_BASE: React.CSSProperties = {\n  position: \"absolute\",\n  willChange: \"top, left\",\n  left: null!,\n  right: null!,\n  top: null!,\n  bottom: null!\n};\n\nexport function getArrowStyle(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n): React.CSSProperties {\n  if (placement.primary.isCenter) {\n    return STYLE_BASE;\n  }\n\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n  const triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];\n\n  const min = arrowOffset + arrow[sizeProperty] / 2;\n  const max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;\n\n  const negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(\n    subjectsBounds,\n    placement,\n    arrowOffset\n  );\n\n  const primarySide = placement.primary.prop;\n  const secondarySide = placement.primary.oppositeCssProp;\n\n  const secondaryValue = triggerIsBigger\n    ? layer[sizeProperty] / 2 + negativeOffset\n    : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];\n\n  return {\n    ...STYLE_BASE,\n    [primarySide]: \"100%\",\n    [secondarySide]: limit(secondaryValue, min, max)\n  };\n}\n","import { CSSProperties } from \"react\";\nimport {\n  BoundSide,\n  Side,\n  BoundSideType,\n  SideType,\n  BoundSideProp,\n  SideProp\n} from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { Placement, PlacementCenter } from \"./Placement\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport {\n  PositionConfig,\n  Offsets,\n  ScrollOffsets,\n  BorderOffsets,\n  DisappearType,\n  Styles\n} from \"./types\";\nimport { Bounds } from \"./Bounds\";\nimport { getArrowStyle } from \"./getArrowStyle\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\n\n/**\n * Class mostly concerned about calculating and finding the right placement\n */\nexport class Placements {\n  protected constructor(\n    public readonly placements: Placement[],\n    private config: PositionConfig,\n    private subjectsBounds: SubjectsBounds\n  ) {}\n\n  /**\n   * Converts a placement-type into a primary-side and a secondary-side\n   */\n  static getSidesFromPlacementType(\n    type: PlacementType\n  ): [BoundSideType, SideType] {\n    let [a, b] = (type.split(\"-\") as unknown) as [\n      keyof typeof BoundSide,\n      \"start\" | \"center\" | \"end\"\n    ];\n\n    const primary = BoundSide[a];\n    let secondary: SideType;\n    if (b === \"center\") {\n      secondary = Side.center;\n    } else if (primary.isHorizontal) {\n      secondary = b === \"start\" ? Side.top : Side.bottom;\n    } else {\n      secondary = b === \"start\" ? Side.left : Side.right;\n    }\n\n    return [primary, secondary];\n  }\n\n  /**\n   * Main static method to create a Placements instance\n   * @param subjectsBounds instance of the SubjectsBounds class\n   * @param config config provided by the user\n   */\n  static create(\n    subjectsBounds: SubjectsBounds,\n    config: PositionConfig\n  ): Placements {\n    // create offsets-object from user config\n    const offsets: Offsets = {\n      arrow: config.arrowOffset,\n      container: config.containerOffset,\n      trigger: config.triggerOffset\n    };\n\n    // function which creates a prioritized list of possible placments\n    // by looking at user-config\n    function getListOfPlacements(preferedPlacement = config.placement) {\n      const [primary, secondary] = Placements.getSidesFromPlacementType(\n        preferedPlacement\n      );\n\n      const preferredSide =\n        BoundSide[primary.isHorizontal ? config.preferY : config.preferX];\n\n      // some priorities may alter when the trigger is bigger\n      const triggerIsBigger =\n        (!primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth) ||\n        (primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight);\n\n      // utility function which constructs a placement by primary and secondary sides\n      function placementFrom(\n        primary: BoundSideType,\n        secondary: SideType\n      ): Placement {\n        return new Placement(\n          primary,\n          secondary,\n          subjectsBounds,\n          config.layerDimensions,\n          offsets\n        );\n      }\n\n      // creating the list\n      let list: Placement[] = [];\n      list[0] = placementFrom(primary, secondary);\n      list[1] = placementFrom(\n        primary,\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[2] = placementFrom(\n        primary,\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n      list[3] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[4] = placementFrom(preferredSide, Side.center);\n      list[5] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[6] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[7] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        Side.center\n      );\n      list[8] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);\n      list[10] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[11] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n\n      // only include placements that are part of 'possible-placements'\n      list = list.filter(\n        placement =>\n          placement.type === config.placement ||\n          config.possiblePlacements.includes(placement.type)\n      );\n\n      return list;\n    }\n\n    // treat placement 'center' a little bit different\n    if (config.placement === \"center\") {\n      return new Placements(\n        [\n          new PlacementCenter(\n            Side.center,\n            Side.center,\n            subjectsBounds,\n            config.layerDimensions,\n            offsets\n          ),\n          ...getListOfPlacements(\n            `${config.preferY}-${config.preferX}` as PlacementType\n          )\n        ],\n        config,\n        subjectsBounds\n      );\n    }\n\n    return new Placements(getListOfPlacements(), config, subjectsBounds);\n  }\n\n  private filterPlacementsBySide(side: SideType): Placement[] {\n    return this.placements.filter(placement => placement.primary === side);\n  }\n\n  private findFirstPlacementThatFits(): Placement | undefined {\n    return this.placements.find(placement => placement.fitsContainer);\n  }\n\n  private placementWithBiggestVisibleSurface(): Placement {\n    const [{ placement: placementWithBiggestSurface }] = this.placements\n      .map(placement => ({\n        placement,\n        surface: placement.visibleSurface\n      }))\n      // sort -> biggest surface first\n      .sort((a, b) => b.surface - a.surface);\n\n    return placementWithBiggestSurface;\n  }\n\n  private findSuitablePlacement(): Placement {\n    if (!this.config.auto) {\n      return this.placements[0];\n    }\n\n    return (\n      this.findFirstPlacementThatFits() ||\n      this.placementWithBiggestVisibleSurface()\n    );\n  }\n\n  /**\n   * secondary offset: the number of pixels between the edge of the\n   * scroll-container and the current placement, on the side of the layer\n   * that didn't fit.\n   * Eventually this secondary offset gets added / subtracted from the\n   * placement that does fit in order to move the layer closer to the\n   * position of the placement that just would not fit.\n   * This creates the effect that the layer is moving gradually from one\n   * placement to the next as the users scrolls the page or scroll-container\n   */\n  private getSecondaryOffset(placement: Placement): number {\n    const { auto, snap } = this.config;\n\n    // return early when we're not interested...\n    if (!auto || snap || placement instanceof PlacementCenter) {\n      return 0;\n    }\n\n    // if current placement fits and is prefered placement...\n    // return early\n    const placementsOnSameSide = this.filterPlacementsBySide(placement.primary);\n    const currentPlacementHasHighestPriority =\n      placementsOnSameSide.indexOf(placement) === 0;\n    if (currentPlacementHasHighestPriority && placement.fitsContainer) {\n      return 0;\n    }\n\n    const firstPlacementThatDoesNotFit = placementsOnSameSide.find(\n      placement => !placement.fitsContainer\n    );\n    if (!firstPlacementThatDoesNotFit) {\n      return 0;\n    }\n    const secondaryOffsetSide = firstPlacementThatDoesNotFit.secondaryOffsetSide!;\n    if (!secondaryOffsetSide) {\n      return 0;\n    }\n\n    const containerOffsets = placement.getContainerOffsets();\n\n    // determine whether we should add or substract the secondary-offset\n    const { secondary } = placement;\n    let factor: number;\n    if (\n      placement.triggerIsBigger ||\n      firstPlacementThatDoesNotFit === placement\n    ) {\n      factor = secondaryOffsetSide.isPush ? -1 : 1;\n    } else {\n      factor =\n        secondary === Side.left ||\n        ([Side.top, Side.center].includes(secondary) &&\n          secondaryOffsetSide.isPush)\n          ? -1\n          : 1;\n    }\n\n    // get number of pixels between placement that did not fit and current\n    // placement\n    const secondaryOffset = containerOffsets[secondaryOffsetSide!.prop];\n\n    return secondaryOffset * factor;\n  }\n\n  private getStyles(\n    layerBounds: Bounds,\n    placement: Placement,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ): Styles {\n    const layerStyleBase: CSSProperties = {\n      willChange: \"top, left, width, height\"\n    };\n\n    const arrow = getArrowStyle(\n      this.subjectsBounds.merge({ layer: layerBounds }),\n      placement,\n      this.config.arrowOffset\n    );\n\n    const layer: CSSProperties = this.config.overflowContainer\n      ? {\n          ...layerStyleBase,\n          position: \"fixed\",\n          top: layerBounds.top,\n          left: layerBounds.left\n        }\n      : {\n          ...layerStyleBase,\n          position: \"absolute\",\n          top:\n            layerBounds.top -\n            this.subjectsBounds.parent.top +\n            scrollOffsets.top -\n            borderOffsets.top,\n          left:\n            layerBounds.left -\n            this.subjectsBounds.parent.left +\n            scrollOffsets.left -\n            borderOffsets.left\n        };\n\n    return {\n      arrow,\n      layer\n    };\n  }\n\n  private getHasDisappeared(layerBounds: Bounds): DisappearType | null {\n    const subject = this.config.overflowContainer\n      ? this.subjectsBounds.trigger\n      : layerBounds;\n\n    const containerOffsets = BoundsOffsets.mergeSmallestSides(\n      this.subjectsBounds.offsetsToScrollContainers(subject, true)\n    );\n\n    const entries = (Object.entries(\n      containerOffsets.negativeSides\n    ) as unknown) as [BoundSideProp, number][];\n\n    const hasFullyDisappeared = entries.some(([prop, value]) => {\n      const side = BoundSide[prop];\n      return value <= -subject[side.sizeProp];\n    });\n\n    if (hasFullyDisappeared) {\n      return \"full\";\n    }\n\n    if (!containerOffsets.allSidesArePositive) {\n      return \"partial\";\n    }\n\n    return null;\n  }\n\n  public result(scrollOffsets: ScrollOffsets, borderOffsets: BorderOffsets) {\n    const suitablePlacement = this.findSuitablePlacement();\n    const secondaryOffset = this.getSecondaryOffset(suitablePlacement);\n    const layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);\n    const styles = this.getStyles(\n      layerBounds,\n      suitablePlacement,\n      scrollOffsets,\n      borderOffsets\n    );\n    const layerSide = suitablePlacement.primary.prop as SideProp;\n\n    return {\n      styles,\n      layerSide,\n      placement: suitablePlacement,\n      layerBounds,\n      hasDisappeared: this.getHasDisappeared(layerBounds)\n    };\n  }\n}\n","import { Bounds, IBounds, boundsToObject } from \"./Bounds\";\n\ninterface ISubjectsBounds {\n  trigger: IBounds;\n  layer: IBounds;\n  arrow: IBounds;\n  parent: IBounds;\n  window: IBounds;\n  scrollContainers: IBounds[];\n}\n\nexport class SubjectsBounds implements ISubjectsBounds {\n  public readonly trigger!: Bounds;\n  public readonly layer!: Bounds;\n  public readonly arrow!: Bounds;\n  public readonly parent!: Bounds;\n  public readonly window!: Bounds;\n  public readonly scrollContainers!: Bounds[];\n\n  private constructor(\n    subjectsBounds: ISubjectsBounds,\n    private readonly overflowContainer: boolean\n  ) {\n    Object.assign(this, subjectsBounds);\n  }\n\n  static create(\n    environment: Window,\n    layer: HTMLElement,\n    trigger: HTMLElement,\n    parent: HTMLElement | undefined,\n    arrow: HTMLElement | null,\n    scrollContainers: HTMLElement[],\n    overflowContainer: boolean,\n    getTriggerBounds?: () => IBounds\n  ) {\n    const window = Bounds.fromWindow(environment);\n\n    return new SubjectsBounds(\n      {\n        layer: Bounds.fromElement(layer, {\n          environment,\n          withTransform: false\n        }),\n        trigger: getTriggerBounds\n          ? Bounds.create(boundsToObject(getTriggerBounds()))\n          : Bounds.fromElement(trigger),\n        arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),\n        parent: parent ? Bounds.fromElement(parent) : window,\n        window,\n        scrollContainers: [\n          window,\n          ...scrollContainers.map(container =>\n            Bounds.fromElement(container, { withScrollbars: false })\n          )\n        ]\n      },\n      overflowContainer\n    );\n  }\n\n  merge(subjectsBounds: Partial<ISubjectsBounds>) {\n    return new SubjectsBounds(\n      {\n        ...this,\n        ...subjectsBounds\n      },\n      this.overflowContainer\n    );\n  }\n\n  get layerOffsetsToScrollContainers() {\n    return this.offsetsToScrollContainers(this.layer);\n  }\n\n  get triggerHasBiggerWidth() {\n    return this.trigger.width > this.layer.width;\n  }\n\n  get triggerHasBiggerHeight() {\n    return this.trigger.height > this.layer.height;\n  }\n\n  offsetsToScrollContainers(subject: Bounds, allContainers = false) {\n    const scrollContainers =\n      this.overflowContainer && !allContainers\n        ? [this.window]\n        : this.scrollContainers;\n\n    return scrollContainers.map(scrollContainer =>\n      scrollContainer.offsetsTo(subject)\n    );\n  }\n}\n","import {\n  useCallback,\n  useState,\n  useRef,\n  createElement,\n  ReactNode,\n  ReactPortal,\n  MutableRefObject,\n  CSSProperties,\n  useEffect\n} from \"react\";\nimport { createPortal } from \"react-dom\";\nimport warning from \"tiny-warning\";\nimport {\n  Options,\n  LayerSide,\n  Styles,\n  ScrollOffsets,\n  BorderOffsets,\n  PositionConfig,\n  RefCallback,\n  Container\n} from \"./types\";\nimport { useTrackElements, OnChangeElements } from \"./useTrackElements\";\nimport { useGroup, GroupProvider } from \"./useGroup\";\nimport { PlacementType, PLACEMENT_TYPES } from \"./PlacementType\";\nimport { Placements } from \"./Placements\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { useLastState } from \"./hooks\";\nimport { isSet, mergeRefs } from \"./util\";\n\nlet GLOBAL_CONTAINER: HTMLElement | null = null;\n\nexport function setGlobalContainer(container: Container) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  warning(\n    !(GLOBAL_CONTAINER instanceof HTMLElement),\n    `react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.`\n  );\n\n  if (typeof container === \"function\") {\n    GLOBAL_CONTAINER = container();\n  } else if (typeof container === \"string\") {\n    GLOBAL_CONTAINER = document.getElementById(container);\n  } else {\n    GLOBAL_CONTAINER = container;\n  }\n\n  warning(\n    GLOBAL_CONTAINER instanceof HTMLElement,\n    `react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element`\n  );\n}\n\nexport type LayerProps = { ref: RefCallback; style: Styles[\"layer\"] };\nexport type TriggerProps = { ref: RefCallback };\nexport type UseLayerArrowProps = {\n  ref: MutableRefObject<any> | RefCallback;\n  layerSide: LayerSide;\n  style: Styles[\"arrow\"];\n};\n\nexport type UseLayerProps = {\n  renderLayer: (children: ReactNode) => ReactPortal | null;\n  triggerProps: TriggerProps;\n  layerProps: LayerProps;\n  arrowProps: UseLayerArrowProps;\n  layerSide: LayerSide;\n  triggerBounds: ClientRect | null;\n};\n\ntype State = {\n  layerSide: LayerSide;\n  styles: Styles;\n};\n\nexport const DEFAULT_OPTIONS: Required<Omit<\n  Options,\n  | \"ResizeObserver\"\n  | \"environment\"\n  | \"onParentClose\"\n  | \"onOutsideClick\"\n  | \"onDisappear\"\n  | \"isOpen\"\n  | \"layerDimensions\"\n>> = {\n  auto: false,\n  arrowOffset: 0,\n  containerOffset: 10,\n  triggerOffset: 0,\n  overflowContainer: true,\n  placement: \"top-center\",\n  possiblePlacements: (PLACEMENT_TYPES as unknown) as PlacementType[],\n  preferX: \"right\",\n  preferY: \"bottom\",\n  snap: false,\n  container: undefined!,\n  trigger: undefined!\n};\n\nexport function useLayer({\n  isOpen = false,\n  overflowContainer = DEFAULT_OPTIONS.overflowContainer,\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ResizeObserver: ResizeObserverPolyfill,\n  placement = DEFAULT_OPTIONS.placement,\n  possiblePlacements = DEFAULT_OPTIONS.possiblePlacements,\n  preferX = DEFAULT_OPTIONS.preferX,\n  preferY = DEFAULT_OPTIONS.preferY,\n  auto = DEFAULT_OPTIONS.auto,\n  snap = DEFAULT_OPTIONS.snap,\n  triggerOffset = DEFAULT_OPTIONS.triggerOffset,\n  containerOffset = DEFAULT_OPTIONS.containerOffset,\n  arrowOffset = DEFAULT_OPTIONS.arrowOffset,\n  container = DEFAULT_OPTIONS.container,\n  layerDimensions = null,\n  onDisappear,\n  onOutsideClick,\n  onParentClose,\n  trigger: triggerOption\n}: Options): UseLayerProps {\n  // initialize styles\n  const [state, setState] = useState<State>(() => ({\n    layerSide:\n      placement === \"center\"\n        ? \"center\"\n        : Placements.getSidesFromPlacementType(placement)[0].prop,\n    styles: {\n      layer: {\n        position: overflowContainer ? \"fixed\" : \"absolute\",\n        top: 0,\n        left: 0\n      },\n      arrow: {\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      }\n    }\n  }));\n\n  const triggerBoundsRef = useRef<HTMLElement>(null!);\n\n  // tracks state in order for us to use read inside functions that require dependencies,\n  // like `useCallback`, without triggering an update\n  const lastState = useLastState(state, isOpen);\n\n  // keeps track of scheduled animation-frames\n  const raf = useRef<any>(null);\n  useEffect(() => {\n    return () => {\n      // when this hook unmounts, make sure to cancel any scheduled animation-frames\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = null;\n      }\n    };\n  }, []);\n\n  // Most important function regarding positioning\n  // It receives boundaries collected by `useTrackElements`, does some calculations,\n  // sets new styles, and handles when a layer has disappeared.\n  const handlePositioning = useCallback(\n    function handlePositioning(\n      { arrow, layer, scrollContainers, trigger }: OnChangeElements,\n      scrollOffsets: ScrollOffsets,\n      borderOffsets: BorderOffsets\n    ) {\n      const parent = scrollContainers[0];\n\n      const subjectsBounds = SubjectsBounds.create(\n        environment!,\n        layer,\n        trigger,\n        parent,\n        arrow,\n        scrollContainers,\n        overflowContainer,\n        triggerOption?.getBounds\n      );\n\n      const config: PositionConfig = {\n        placement,\n        possiblePlacements,\n        auto,\n        layerDimensions,\n        arrowOffset,\n        containerOffset,\n        triggerOffset,\n        preferX,\n        preferY,\n        snap,\n        overflowContainer\n      };\n\n      const { hasDisappeared, layerSide, styles } = Placements.create(\n        subjectsBounds,\n        config\n      ).result(scrollOffsets, borderOffsets);\n\n      const newState: State = {\n        layerSide,\n        styles\n      };\n\n      if (!lastState.current || didStateChange(lastState.current, newState)) {\n        lastState.current = newState; // optimistically update lastState to prevent infinite loop\n\n        /**\n         * We're using requestAnimationFrame-features here to ensure that position updates will\n         * happen max once per frame.\n         * If during a frame there's already an update scheduled, the existing update will be cancelled\n         * and the new update will take precedence.\n         */\n        if (raf.current) {\n          cancelAnimationFrame(raf.current);\n        }\n\n        raf.current = requestAnimationFrame(() => {\n          setState(newState);\n          raf.current = null;\n        });\n      }\n\n      if (isSet(hasDisappeared) && isSet(onDisappear)) {\n        onDisappear(hasDisappeared);\n      }\n    },\n    [\n      arrowOffset,\n      auto,\n      containerOffset,\n      environment,\n      layerDimensions,\n      onDisappear,\n      overflowContainer,\n      placement,\n      possiblePlacements,\n      preferX,\n      preferY,\n      snap,\n      triggerOffset,\n      lastState,\n      triggerOption\n    ]\n  );\n\n  const {\n    triggerRef,\n    layerRef,\n    arrowRef,\n    closestScrollContainer\n  } = useTrackElements({\n    ResizeObserverPolyfill,\n    environment,\n    enabled: isOpen,\n    overflowContainer,\n    onChange: handlePositioning,\n    triggerOption\n  });\n\n  const { closeOnOutsideClickRefs, registrations } = useGroup({\n    isOpen,\n    onOutsideClick,\n    onParentClose\n  });\n\n  const props: UseLayerProps = {\n    triggerProps: Boolean(triggerOption)\n      ? ({} as any) // when using the `trigger` option, make `triggerProps` useless\n      : {\n          ref: mergeRefs(\n            triggerRef,\n            closeOnOutsideClickRefs.trigger,\n            triggerBoundsRef\n          )\n        },\n    layerProps: {\n      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),\n      style: state.styles.layer\n    },\n    arrowProps: {\n      ref: arrowRef,\n      style: state.styles.arrow,\n      layerSide: state.layerSide\n    },\n    layerSide: state.layerSide,\n    triggerBounds: isOpen\n      ? triggerOption\n        ? triggerOption.getBounds()\n        : triggerBoundsRef.current?.getBoundingClientRect()\n      : null,\n    renderLayer: children =>\n      typeof document !== \"undefined\"\n        ? createPortal(\n            createElement(GroupProvider, { registrations, children }),\n            overflowContainer || !closestScrollContainer\n              ? getContainerElement(container)\n              : closestScrollContainer\n          )\n        : null\n  };\n\n  return props;\n}\n\nfunction didStateChange(previous: State, next: State): boolean {\n  if (previous.layerSide !== next.layerSide) {\n    return true;\n  }\n\n  const styleProps: Array<keyof CSSProperties> = [\n    \"position\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\"\n  ];\n  for (const prop of styleProps) {\n    if (\n      previous.styles.layer[prop] !== next.styles.layer[prop] ||\n      previous.styles.arrow[prop] !== next.styles.arrow[prop]\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst DEFAULT_CONTAINER_ID = \"layers\";\n\nfunction getContainerElement(container?: Container): HTMLElement {\n  let element: HTMLElement;\n\n  if (typeof container === \"function\") {\n    element = container();\n    if (!element || !(element instanceof HTMLElement)) {\n      throw new Error(\n        `react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (container instanceof HTMLElement) {\n    element = container;\n  } else if (typeof container === \"string\") {\n    element = document.getElementById(container)!;\n    if (!element) {\n      throw new Error(\n        `react-laag: You've passed element with id '${container}' to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {\n    return GLOBAL_CONTAINER;\n  } else {\n    element = document.getElementById(DEFAULT_CONTAINER_ID)!;\n    if (!element) {\n      element = document.createElement(\"div\");\n      element.id = DEFAULT_CONTAINER_ID;\n      element.style.cssText = `\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        right: 0px;\n      `;\n      document.body.appendChild(element);\n    }\n  }\n\n  return element;\n}\n","import { createElement, forwardRef } from \"react\";\nimport { BoundSide, BoundSideType } from \"./Sides\";\nimport { LayerSide } from \"./types\";\n\nconst LEFT = \"left\";\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst RIGHT = \"right\";\n\nfunction getWidthBasedOnAngle(angle: number, size: number) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  borderWidth: number\n) {\n  const map = {\n    [BOTTOM]: `0 ${-borderWidth} ${sizeB} ${sizeA}`,\n    [TOP]: `0 0 ${sizeB} ${sizeA + borderWidth}`,\n    [RIGHT]: `${-borderWidth} 0 ${sizeA} ${sizeB}`,\n    [LEFT]: `0 0 ${sizeA + borderWidth} ${sizeB}`\n  };\n\n  return map[side.prop];\n}\n\nfunction getTrianglePath(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  roundness: number,\n  angle: number\n) {\n  const relativeRoundness = (roundness / 10) * sizeA * 2;\n\n  const A = {\n    [BOTTOM]: [0, sizeA],\n    [TOP]: [0, 0],\n    [RIGHT]: [sizeA, sizeB],\n    [LEFT]: [0, sizeB]\n  }[side.prop].join(\" \");\n\n  const B = side.isHorizontal ? `V 0` : `H ${sizeB}`;\n\n  const cPoint = sizeB / 2;\n  const c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  const c1B = sizeA / 8;\n\n  const C = {\n    [BOTTOM]: [\"C\", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0],\n    [TOP]: [\n      \"C\",\n      c1A,\n      sizeA - c1B,\n      cPoint + relativeRoundness,\n      sizeA,\n      cPoint,\n      sizeA\n    ],\n    [RIGHT]: [\"C\", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint],\n    [LEFT]: [\n      \"C\",\n      sizeA - c1B,\n      sizeB - c1A,\n      sizeA,\n      cPoint - relativeRoundness,\n      sizeA,\n      cPoint\n    ]\n  }[side.prop].join(\" \");\n\n  const d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  const d1B = sizeA / 8;\n\n  const D = {\n    [BOTTOM]: [\"C\", cPoint - relativeRoundness, 0, d1A, d1B, A],\n    [TOP]: [\"C\", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A],\n    [RIGHT]: [\"C\", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A],\n    [LEFT]: [\n      \"C\",\n      sizeA,\n      cPoint + relativeRoundness,\n      sizeA - d1B,\n      sizeB - d1A,\n      A\n    ]\n  }[side.prop].join(\" \");\n\n  return [\"M\", A, B, C, D].join(\" \");\n}\n\nfunction getBorderMaskPath(\n  sizeA: number,\n  sizeB: number,\n  borderWidth: number,\n  side: BoundSideType,\n  angle: number\n) {\n  const borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  const [A, B] = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth];\n\n  if (side.isHorizontal) {\n    return [\n      \"M\",\n      A,\n      borderWidth,\n      \"V\",\n      sizeB - borderWidth,\n      \"L\",\n      B,\n      sizeB - borderWidth - borderOffset,\n      \"V\",\n      borderOffset + borderWidth,\n      \"Z\"\n    ].join(\" \");\n  }\n\n  return [\n    \"M\",\n    borderWidth,\n    A,\n    \"H\",\n    sizeB - borderWidth,\n    \"L\",\n    sizeB - borderWidth - borderOffset,\n    B,\n    \"H\",\n    borderOffset + borderWidth,\n    \"Z\"\n  ].join(\" \");\n}\n\nexport type ArrowProps = React.ComponentPropsWithoutRef<\"svg\"> & {\n  /**\n   * angle of triangle\n   * default is `45`\n   */\n  angle?: number;\n  /**\n   * distance in pixels between point of triangle and layer\n   * default is `8`\n   */\n  size?: number;\n  /**\n   * roundness of the point of the arrow\n   * range: 0 - 1\n   * default is `0`\n   */\n  roundness?: number;\n  /**\n   * width of the layers border\n   * default is `0`\n   */\n  borderWidth?: number;\n  /**\n   * color of the layers border\n   * default is `\"black\"`\n   */\n  borderColor?: string;\n  /**\n   * background-color of the layer\n   * default is `\"white\"`\n   */\n  backgroundColor?: string;\n  /**\n   * Given by `useLayer()` and determines the direction the arrow should\n   * be pointing to\n   */\n  layerSide?: LayerSide;\n};\n\nexport const Arrow = forwardRef<SVGSVGElement, ArrowProps>(function Arrow(\n  {\n    size = 8,\n    angle = 45,\n    borderWidth = 0,\n    borderColor = \"black\",\n    roundness = 0,\n    backgroundColor = \"white\",\n    layerSide = \"top\",\n    style = {},\n    ...rest\n  },\n  ref\n) {\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  const side = BoundSide[layerSide];\n  const sizeA = size;\n  const sizeB = getWidthBasedOnAngle(angle, size) * 2;\n\n  const maxSize = Math.max(sizeA, sizeB);\n\n  return createElement(\n    \"svg\",\n    {\n      ref,\n      ...rest,\n      style: {\n        ...style,\n        transform: `translate${side.isHorizontal ? \"Y\" : \"X\"}(-50%)`\n      },\n      width: maxSize,\n      height: maxSize,\n      preserveAspectRatio: side.isPush ? \"xMinYMin\" : \"xMaxYMax\",\n      viewBox: getViewBox(sizeA, sizeB, side, borderWidth)\n    },\n    createElement(\"path\", {\n      fill: backgroundColor,\n      strokeWidth: borderWidth,\n      stroke: borderColor,\n      d: getTrianglePath(sizeA, sizeB, side, roundness, angle)\n    }),\n    createElement(\"path\", {\n      fill: backgroundColor,\n      d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)\n    })\n  );\n});\n","import { useState, useRef, useCallback, useEffect, MouseEvent } from \"react\";\n\nexport type UseHoverOptions = {\n  /**\n   * Amount of milliseconds to wait while hovering before opening.\n   * Default is `0`\n   */\n  delayEnter?: number;\n  /**\n   * Amount of milliseconds to wait when mouse has left the trigger before closing.\n   * Default is `0`\n   */\n  delayLeave?: number;\n  /**\n   * Determines whether the layer should hide when the user starts scrolling.\n   * Default is `true`\n   */\n  hideOnScroll?: boolean;\n};\n\nexport type PlainCallback = (...args: any[]) => void;\n\nexport type UseHoverProps = {\n  onMouseEnter: PlainCallback;\n  onMouseLeave: PlainCallback;\n  onTouchStart: PlainCallback;\n  onTouchMove: PlainCallback;\n  onTouchEnd: PlainCallback;\n};\n\nenum Status {\n  ENTERING,\n  LEAVING,\n  IDLE\n}\n\nexport function useHover({\n  delayEnter = 0,\n  delayLeave = 0,\n  hideOnScroll = true\n}: UseHoverOptions = {}): readonly [boolean, UseHoverProps, () => void] {\n  const [show, setShow] = useState(false);\n\n  const timeout = useRef<number | null>(null);\n\n  const status = useRef<Status>(Status.IDLE);\n\n  const hasTouchMoved = useRef<boolean>(false);\n\n  const removeTimeout = useCallback(function removeTimeout() {\n    clearTimeout(timeout.current!);\n    timeout.current = null;\n    status.current = Status.IDLE;\n  }, []);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (status.current === Status.LEAVING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (show) {\n      return;\n    }\n\n    status.current = Status.ENTERING;\n    timeout.current = setTimeout(() => {\n      setShow(true);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayEnter);\n  }\n\n  function onMouseLeave(_: MouseEvent<any>, immediate?: boolean) {\n    // if was waiting for entering,\n    // clear timeout\n    if (status.current === Status.ENTERING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (!show) {\n      return;\n    }\n\n    if (immediate) {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n      return;\n    }\n\n    status.current = Status.LEAVING;\n    timeout.current = setTimeout(() => {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayLeave);\n  }\n\n  // make sure to clear timeout on unmount\n  useEffect(() => {\n    const currentTimeout = timeout.current;\n\n    function onScroll() {\n      if (show && hideOnScroll) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    function onTouchEnd() {\n      if (show) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n    window.addEventListener(\"touchend\", onTouchEnd, true);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n      window.removeEventListener(\"touchend\", onTouchEnd, true);\n\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n    };\n  }, [show, hideOnScroll, removeTimeout]);\n\n  const hoverProps: UseHoverProps = {\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart: () => {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: () => {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: () => {\n      if (!hasTouchMoved.current && !show) {\n        setShow(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n\n  return [show, hoverProps, () => onMouseLeave(null!, true)] as const;\n}\n","import { useState, useRef, useEffect } from \"react\";\n\nexport type TransitionProps = {\n  isOpen: boolean;\n  children: (\n    isOpen: boolean,\n    onTransitionEnd: any,\n    isLeaving: boolean\n  ) => React.ReactElement;\n};\n\n/**\n * @deprecated\n * Note: this component is marked as deprecated and will be removed and a possible\n * future release\n */\nexport function Transition({\n  isOpen: isOpenExternal,\n  children\n}: TransitionProps) {\n  const [state, setState] = useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  });\n\n  const didMount = useRef(false);\n\n  useEffect(() => {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n\n  useEffect(() => {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(\n    state.isOpenInternal,\n    () => {\n      if (!state.isOpenInternal) {\n        setState(s => ({ ...s, isLeaving: false }));\n      }\n    },\n    state.isLeaving\n  );\n}\n"]},"metadata":{},"sourceType":"module"}